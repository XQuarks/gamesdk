{
  "comments": [
    {
      "key": {
        "uuid": "7d84f540_8dbb64b6",
        "filename": "bender/bender-base/app/src/main/jni/texture.cc",
        "patchSetId": 4
      },
      "lineNbr": 70,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "Traditionally, this should be RGBA \u003d 255,0,255,255 because magenta is really hard to find in the real world unless you do it deliberately. No change needed though.\n\nIn general, try to avoid reading/writing data in bytes unless you\u0027re dealing with strings - it makes the math easier to mess up :)\n\nFor example, you might do this as:\n\n#if PLATFORM_IS_BIG_ENDIAN\nconstexpr bool kPlatformIsLittleEndian \u003d false;\n#else\nconstexpr bool kPlatformIsLittleEndian \u003d true;\n#endif\n\nconstexpr size_t kBytesPerPixel_R8G8B8A8 \u003d 4;\n\n// Convert Decimal RGBA values to uint32_t \nconstexpr uint32_t RGBA( uint8_t red, uint8_t green, uint8_t blue, uint8_t opacity \u003d 0xFF )\n{\n  // This should be correct for little-endian platforms, which are the majority today:\n  if (kPlatformIsLittleEndian) {\n    return opacity \u003c\u003c 24 | blue \u003c\u003c 16 | green \u003c\u003c 8 | red;\n  } else {\n    return red \u003c\u003c 24 | green \u003c\u003c 16 | blue \u003c\u003c 8 | opacity;\n  }\n}\n\nconstexpr uint32_t kMissingTextureColorRGBA \u003d RGBA(215,95,175,255);\n\nconstexpr size_t CalculateStride( size_t linewidthbytes ) {\n  return linewidthbytes; // on some GPUs we might need to round up to nearest 64-bytes, or similar.\n}\n\nuint8_t* Texture::LoadFallbackData() {\n  assert( ( texture_format_ \u003d\u003d VK_FORMAT_R8G8B8A8_SRG ) \u0026\u0026 \"Unsupported texture format\");\n\n  if ( texture_format_ \u003d\u003d VK_FORMAT_R8G8B8A8_SRGB )\n  {\n    tex_width_ \u003d 128;\n    tex_height_ \u003d 128;\n    size_t bytes_per_line \u003d tex_width_ * kBytesPerPixel_R8G8B8A8;\n    size_t stride \u003d CalculateStride( bytes_per_line ); // stride might need to be a member var.\n    size_t total_bytes \u003d stride * tex_height_;\n    \n    uint8_t* img_data \u003d (uint8_t*)malloc(total_bytes);\n\n    uint8_t* line_start \u003d img_data;\n\n    for ( uint32_t i \u003d 0; i \u003c tex_height_; i++ ) {\n      uint32_t* line \u003d reinterpret_cast\u003cuint32_t*\u003e(line_start);\n\n      for ( uint32_t j \u003d 0; j \u003c tex_width_; j++ ) {\n        line[j] \u003d kMissingTextureColorRGBA;\n      }\n\n      line_start +\u003d stride;\n    }\n  }\n  ... other stuff goes here ...\n}\n\nNOTE: You should also set the texture format inside LoadFallbackData(), or check it on entry and generate output in the right fallback format. Doesn\u0027t matter so much for color RGBA textures, but once you start working with other compression formats, or single/dual channel textures it\u0027ll matter.\n\nNote2: You\u0027d need to look at the generated assembly to see if that inner j loop is faster using array indexing or by adding 1 to j eaach time through the loop. On intel, it should be faster this way. Not sure for ARM.\n\nNOTE3: We should look at adding helpers for pixels, formats, and so on in the future :D",
      "range": {
        "startLine": 57,
        "startChar": 0,
        "endLine": 70,
        "endChar": 1
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "798e5023_24ff6262",
        "filename": "bender/bender-base/app/src/main/jni/texture.cc",
        "patchSetId": 4
      },
      "lineNbr": 74,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "This is a minor nit, but generally, you should prefer /not/ using new[] for large allocations - like, say, textures.\n\nSome malloc/new implementations don\u0027t handle \u003e 4KiB allocations well, or defer to the system page allocator - instead, it makes more sense to use mmap(). (There\u0027s also the problem that passing around a raw uchar* buffer leaves the question of ownership).\n\nInstead, at a minimum we should have a buffer class (with move semantics) that we pass around - \n\n#include \u003cstdlib.h\u003e\n\nstruct Buffer final {\n  void* buffer_;\n  size_t size_;\n  align_t alignment_;\n\n  Buffer() : buffer_ (nullptr), size_ (0), alignment_ (0) {\n  };\n\n  Buffer(const Buffer\u0026 copy) \u003d delete;\n\n  ~Buffer() {\n    Free();\n  }\n\n  Buffer( Buffer\u0026\u0026 move ) {\n    if ( \u0026move !\u003d this ) {\n      *this \u003d move;\n    }\n  }\n\n  Buffer\u0026 operator\u003d( Buffer\u0026\u0026 move ) {\n    if ( this !\u003d \u0026move ) {\n      buffer_ \u003d move.buffer_;\n      size_ \u003d move.buffer_size;\n      move.buffer_ \u003d nullptr;\n    }\n  }\n\n  Buffer\u0026 operator\u003d( const Buffer\u0026 copy ) \u003d delete;\n\n  void Allocate( size_t size, align_t alignment \u003d 1 ) {\n    buffer_ \u003d aligned_alloc( aligment, size );\n    size_ \u003d size;\n  }\n\n  void Free() {\n    if ( buffer_ ) {\n      aligned_free( buffer_ );\n      buffer_ \u003d nullptr;\n    }\n  }\n\n};\n\nThis gets more important if using raw textures - on some architectures, there are page-alignment requirements for texture data. \n\nWe should revisit how memory is used to load assets \u0026 textures at some point in the future - not now - because (1) allocations are always expensive, and (2) so are memcpy operations. We may be able to reduce both, leading to a large perf savings. If it\u0027s possible to load a texture directly into the right place in memory so that it can be immediately used by the GPU, we should.",
      "range": {
        "startLine": 74,
        "startChar": 2,
        "endLine": 74,
        "endChar": 57
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eea71af6_5f119fd2",
        "filename": "bender/bender-base/app/src/main/jni/texture.cc",
        "patchSetId": 4
      },
      "lineNbr": 97,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "As above, in this case we probably want to decide what format this texture should be in this instance, and either pass it to LoadFallbackData() or set it in LoadFallbackData().",
      "range": {
        "startLine": 97,
        "startChar": 2,
        "endLine": 97,
        "endChar": 30
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a513a78c_21e15c0a",
        "filename": "bender/bender-base/app/src/main/jni/texture.cc",
        "patchSetId": 4
      },
      "lineNbr": 117,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "Replace with buffer type.",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 117,
        "endChar": 26
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0dc0bd8a_601b889e",
        "filename": "bender/bender-base/app/src/main/jni/texture.cc",
        "patchSetId": 4
      },
      "lineNbr": 129,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "As mentioned above, let\u0027s get rid of the magic numbers... \n\nInstead of 4 in the img_bytes calculation, use a constant - e.g. kBytesPerPixel_R8G8B8A8 - as it makes it explicit. \nNote: the logic here doesn\u0027t keep track of which texture format it\u0027s expecting, so we should revisit this at some point to make it consistent.\n\nIs there any way we can get the magic numbers out of the mip_levels calculation?",
      "range": {
        "startLine": 119,
        "startChar": 0,
        "endLine": 129,
        "endChar": 63
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1334f08d_176e82ea",
        "filename": "bender/bender-base/app/src/main/jni/texture.h",
        "patchSetId": 4
      },
      "lineNbr": 48,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "should be uint32_t to match the API (Vulkan uses uint32 for width/height)? I can see arguments either way here. The only real requirement is consistency.",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 48,
        "endChar": 52
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90ed4352_972ea25d",
        "filename": "bender/bender-base/app/src/main/jni/texture.h",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "Might need to be uint32_t.",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 59,
        "endChar": 22
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1692c99_a80dcf0b",
        "filename": "bender/bender-base/app/src/main/jni/vulkan_main.cc",
        "patchSetId": 4
      },
      "lineNbr": 298,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "At some point in the future we should move this decision to the binary file that Chef creates, and have the toggle switch between two different files - which means storing the asset format/compression in the binary data.\n\nEventually we\u0027ll end up with some kind of XML (or YAML, or JSON) format that encodes all this info, Chef reads a raw PNG, spits out all the compressed output variants which use that asset for different build flavors (e.g. Windows/Mobile), and then moves onto the next asset. This also reduces data crunching time as you only load the input data into memory once.\n\nWhen we get to that point, we\u0027d have the raw PNG, the compression to use, and the uncompressed texture format to use in-engine.",
      "range": {
        "startLine": 286,
        "startChar": 0,
        "endLine": 298,
        "endChar": 5
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dfabb9e4_e592dba7",
        "filename": "bender/bender-base/convert_astc.sh",
        "patchSetId": 4
      },
      "lineNbr": 19,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "Are there any special requirements for using this script in Omar\u0027s build? \n\nI\u0027m guessing that we need bash as a prereq for Chef. Image Magick too. \n\nI don\u0027t know the answer here: Should we stick with bash on Windows, or should we require python on all platforms? Or something else?",
      "range": {
        "startLine": 3,
        "startChar": 0,
        "endLine": 19,
        "endChar": 60
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a11d09cd_4613eaf8",
        "filename": "bender/bender-base/utils/src/astc.h",
        "patchSetId": 4
      },
      "lineNbr": 33,
      "author": {
        "id": 1566081
      },
      "writtenOn": "2020-05-19T23:31:29Z",
      "side": 1,
      "message": "Use constexpr here...\n\nconstexpr VkFormat GetASTCFormat(uint8_t block_dim_x, uint8_t block_dim_y) {",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 45
      },
      "revId": "04633b15e2d8f3026f5d1d2218e37ccba11d52ed",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}