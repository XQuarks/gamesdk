{
  "comments": [
    {
      "key": {
        "uuid": "c6e3dd0d_90297151",
        "filename": "src/swappyVk/SwappyVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1098333
      },
      "writtenOn": "2018-12-11T20:20:12Z",
      "side": 1,
      "message": "What is this?",
      "revId": "9f31ddf9d7db141dccc83bbc894764f8fdee7b6d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a27949f_90c77e35",
        "filename": "src/swappyVk/SwappyVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1388190
      },
      "writtenOn": "2018-12-12T00:33:49Z",
      "side": 1,
      "message": "See https://android.googlesource.com/platform/frameworks/opt/gamesdk/+/master/third_party/cube/app/src/main/cpp/common/vulkan_wrapper.cpp#24\n\nThis is where vk* function pointer are assigned from dlopen",
      "parentUuid": "c6e3dd0d_90297151",
      "revId": "9f31ddf9d7db141dccc83bbc894764f8fdee7b6d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28651003_5e4861e6",
        "filename": "src/swappyVk/SwappyVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 119,
      "author": {
        "id": 1388190
      },
      "writtenOn": "2018-12-18T22:57:13Z",
      "side": 1,
      "message": "Resolved",
      "parentUuid": "7a27949f_90c77e35",
      "revId": "9f31ddf9d7db141dccc83bbc894764f8fdee7b6d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a734f47_cd61fc75",
        "filename": "src/swappyVk/SwappyVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 677,
      "author": {
        "id": 1098333
      },
      "writtenOn": "2018-12-07T21:54:36Z",
      "side": 1,
      "message": "There might be danger with this approach.  I haven\u0027t fully thought through this, and so I may be wrong.\n\nOne of the problems with QP is that the application doesn\u0027t really know when it\u0027s safe to delete the semaphore(s) given to QP (there\u0027s currently no feedback mechanism).  There\u0027s a proposed extension to provide a fence that will say when its safe for the application to delete them.  Either way, the application **might** delete the semaphore(s) before your code waits for them.  I **think** in that case, the application would crash because of what SwappyVk does.\n\nPut differently, Vulkan allows applications to crash, when the API is used improperly.  In this case, you are re-using an application object(s) without its knowledge, in a potentially-dangerous way.\n\nThinking more, I think you\u0027re okay.  You\u0027re creating/submitting a fence that will be signaled after the semaphore is signaled.  You\u0027re not relying on the semaphore living until you check the fence; you\u0027re only relying on your fence continuing to live until then.\n\nSorry for all of the \"thinking out loud\", but I wanted to get you thinking through these things, in case you already haven\u0027t.",
      "revId": "9f31ddf9d7db141dccc83bbc894764f8fdee7b6d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1619cbc_644b797f",
        "filename": "src/swappyVk/SwappyVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 677,
      "author": {
        "id": 1388190
      },
      "writtenOn": "2018-12-10T18:10:10Z",
      "side": 1,
      "message": "The way I see this is that now we are using the app semaphore earlier that what the application would normally use it (we use it in the QueueSubmit before QueuePresent is called), so as long as there was no problem with this semaphore so far, we are not introducing a new one.\n\nThis is an interesting issue though, how the app can do cleanup for this semaphore if it might be in use by the presentation layer. I guess that most applications would create bunch of semaphores, associate then with the swapchain, and never delete them until the swapchain is deleted. This looks safe to me as app uses vkDeviceWaitIdle() that suppose to make sure there is nothing pending in the queues.",
      "parentUuid": "7a734f47_cd61fc75",
      "revId": "9f31ddf9d7db141dccc83bbc894764f8fdee7b6d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf380d7d_ea13fe9f",
        "filename": "src/swappyVk/SwappyVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 677,
      "author": {
        "id": 1388190
      },
      "writtenOn": "2018-12-18T22:57:13Z",
      "side": 1,
      "message": "Resolved",
      "parentUuid": "c1619cbc_644b797f",
      "revId": "9f31ddf9d7db141dccc83bbc894764f8fdee7b6d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}