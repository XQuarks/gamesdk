<html lang="en">
<head>
  <script src="https://www.gstatic.com/external_hosted/dygraphs/dygraph-combined.js"></script>
  <title>Memory report</title>
</head>
<style>/*css*/</style>
<script type="module">

  function flattenParams(params1) {
    let params = {};
    const coordinates = params1.coordinates;
    const tests = params1.tests;

    for (let coordinateNumber = 0; coordinateNumber !== coordinates.length; coordinateNumber++) {
      const dimensionParams = tests[coordinateNumber][coordinates[coordinateNumber]];
      merge(dimensionParams, params);
    }
    return params;
  }

  function merge(in0, out)  {
    in0 = JSON.parse(JSON.stringify(in0));  // Allows copies of mutables to be taken safely.
    for (const [key, value] of Object.entries(in0)) {
      if (key in out) {
        const outObject = out[key];
        if (Array.isArray(outObject) && Array.isArray(value)) {
          for (let idx = 0; idx !== value.length; idx++) {
            outObject.push(value[idx]);
          }
          continue;
        } else if (outObject.constructor === Object && value.constructor === Object) {
          merge(value, outObject);
          continue;
        }
      }
      out[key] = value;
    }
  }

  const capitalizeFirstLetter =
      str => str.charAt(0).toUpperCase() + str.slice(1);

  const onTrimCodes = {
    0: "TRIM_MEMORY_UNKNOWN",
    5: "TRIM_MEMORY_RUNNING_MODERATE",
    10: "TRIM_MEMORY_RUNNING_LOW",
    15: "TRIM_MEMORY_RUNNING_CRITICAL",
    20: "TRIM_MEMORY_UI_HIDDEN",
    40: "TRIM_MEMORY_BACKGROUND",
    60: "TRIM_MEMORY_MODERATE",
    80: "TRIM_MEMORY_COMPLETE"
  };

  const data = [/*data*/];
  for (const result of data) {

    const first = result[0];

    result.sort((a, b) => a.time > b.time ? 1 : -1);

    const section = document.createElement("section");
    document.body.appendChild(section);

    const build = first["build"];
    const constant = first["metrics"]["constant"];

    const heading = document.createElement("h1");
    section.appendChild(heading);
    heading.appendChild(document.createTextNode(
        capitalizeFirstLetter(build.MANUFACTURER) + " " + build.MODEL));

    const table = document.createElement("table");
    section.appendChild(table);

    for (const [key, value] of Object.entries(build)) {
      const row = document.createElement("tr");
      table.appendChild(row);
      {
        const cell = document.createElement("td");
        row.appendChild(cell);
        const node = document.createTextNode(key);
        cell.appendChild(node);
      }
      {
        const cell = document.createElement("td");
        row.appendChild(cell);
        const node = document.createTextNode(value);
        cell.appendChild(node);
      }
    }

    {
      const paragraph = document.createElement("p");
      section.appendChild(paragraph);
      paragraph.appendChild(
              document.createTextNode(`Params: ${JSON.stringify(flattenParams(first.params))}`));
    }

    {
      const paragraph = document.createElement("p");
      section.appendChild(paragraph);
      paragraph.appendChild(
          document.createTextNode(`Settings: ${JSON.stringify(first.settings)}`));
    }

    if ("extra" in first) {
      const extra = first.extra;
      if ("fromLauncher" in extra) {
        const fromLauncher = extra.fromLauncher;
        const h1 = document.createElement("h1");
        section.appendChild(h1);
        let fullName;
        if (fromLauncher.name.indexOf(fromLauncher.manufacturer) === -1) {
          fullName = `${fromLauncher.manufacturer} ${fromLauncher.name}`;
        } else {
          fullName = fromLauncher.name;
        }
        fullName += ` (${fromLauncher.id})`;
        h1.appendChild(document.createTextNode(fullName));
        const img = document.createElement("img");
        img.src = fromLauncher.thumbnailUrl;
        h1.appendChild(img);
      }
      {
        const paragraph = document.createElement("p");
        section.appendChild(paragraph);
        const anchor = document.createElement("a");
        paragraph.appendChild(anchor);
        anchor.href = extra.resultsPage;
        anchor.appendChild(document.createTextNode("Results page"));
      }
      {
        const paragraph = document.createElement("p");
        section.appendChild(paragraph);
        const anchor = document.createElement("a");
        paragraph.appendChild(anchor);
        anchor.href = extra.logs;
        anchor.appendChild(document.createTextNode("Logs"));
      }
    }

    const graphDiv = document.createElement("div");
    section.appendChild(graphDiv);
    graphDiv.classList.add("graph");

    const highlights = [];

    const annotations = [];
    let pausedStart = -1;
    let lowMemoryStart = -1;
    let serviceCrashedStart = -1;
    let allocFailedStart = -1;
    let activityPausedStart = -1;
    const graphData = [];

    let time = 0;

    const fields = ["Time"];
    const rowOut = [0];
    for (const row of result) {
      if (!("time" in row)) {
        continue;
      }
      if (!("metrics" in row)) {
        continue;
      }

      let applicationAllocated = 0;
      if ("testMetrics" in row) {
        for (const value of Object.values(row.testMetrics)) {
          applicationAllocated += value;
        }
      }
      row.applicationAllocated = applicationAllocated;

      rowOut[0] = row.time / 1000;
      const combined = {};
      for (const [field, value] of Object.entries(constant).sort()) {
        combined[field] = value;
      }

      for (const [field, value] of Object.entries(row).sort()) {
        combined[field] = value;
      }

      if ("metrics" in row) {
        for (const [field, value] of Object.entries(row.metrics).sort()) {
          combined[field] = value;
        }
      }

      if ("predictions" in row) {
        const predictions = row.predictions;
        for (const [field, value] of Object.entries(predictions).sort()) {
          const totalPrediction = value + row.applicationAllocated;
          combined["prediction_" + field] = totalPrediction >= 0 ? totalPrediction : 0;
        }
      }

      for (const [field, value] of Object.entries(combined)) {
        if (typeof value !== 'number') {
          continue;
        }
        if (fields.indexOf(field) === -1) {
          fields.push(field);
          for (const existingRow of graphData) {
            existingRow.push(0);
          }
        }
        rowOut[fields.indexOf(field)] = field === "oom_score" ? value : value / (1024 * 1024);
      }

      graphData.push(rowOut.slice(0));

      time = rowOut[0];
      if ("exiting" in row) {
        annotations.push(
            {
              series: "applicationAllocated",
              x: time,
              shortText: "E",
              text: "Exiting"
            }
        );
      }
      if ("onDestroy" in row) {
        annotations.push(
            {
              series: "applicationAllocated",
              x: time,
              shortText: "D",
              text: "onDestroy"
            }
        );
      }
      if ("onTrimMemory" in row) {
        annotations.push(
            {
              series: "applicationAllocated",
              x: time,
              shortText: row.onTrimMemory,
              text: onTrimCodes[row.onTrimMemory]
            }
        );
      }

      if ("warnings" in row) {
        const warnings = row.warnings;
        for (let idx = 0; idx !== warnings.length; idx++) {
          let warning = warnings[idx];
          if (warning.level !== "red") {
            continue;
          }
          for (const key of warning) {
            annotations.push(
                {
                  series: "applicationAllocated",
                  x: time,
                  shortText: key,
                  text: key
                }
            );
          }
        }
      }

      if ("activityPaused" in row) {
        if (row["activityPaused"]) {
          if (activityPausedStart === -1) {
            activityPausedStart = time;
          }
        } else if (activityPausedStart !== -1) {
          highlights.push([activityPausedStart, time, "lightgrey"]);
          activityPausedStart = -1;
        }
      }

      let paused = !!row["paused"];
      if (paused && pausedStart === -1) {
        pausedStart = time;
      } else if (!row.paused && pausedStart !== -1) {
        highlights.push([pausedStart, time, "yellow"]);
        pausedStart = -1;
      }

      if ("metrics" in row) {
        let lowMemory = !!row.metrics.lowMemory;
        if (lowMemory && lowMemoryStart === -1) {
          lowMemoryStart = time;
        } else if (!lowMemory && lowMemoryStart !== -1) {
          highlights.push([lowMemoryStart, time, "pink"]);
          lowMemoryStart = -1;
        }
      }

      let serviceCrashed = !!row["serviceCrashed"];
      if (serviceCrashed && serviceCrashedStart === -1) {
        serviceCrashedStart = time;
      } else if (!serviceCrashed && serviceCrashedStart !== -1) {
        highlights.push([serviceCrashedStart, time, "cyan"]);
        serviceCrashedStart = -1;
      }

      let allocFailed = !!row["allocFailed"] || !!row["mmapAnonFailed"] || !!row["mmapFileFailed"];
      if (allocFailed && allocFailedStart === -1) {
        allocFailedStart = time;
      } else if (!allocFailed && allocFailedStart !== -1) {
        highlights.push([allocFailedStart, time, "lightblue"]);
        allocFailedStart = -1;
      }
    }

    if (activityPausedStart !== -1) {
      highlights.push([activityPausedStart, time, "lightgrey"]);
      allocFailedStart = -1;
    }
    if (pausedStart !== -1) {
      highlights.push([pausedStart, time, "yellow"]);
    }
    if (lowMemoryStart !== -1) {
      highlights.push([lowMemoryStart, time, "pink"]);
    }
    if (serviceCrashedStart !== -1) {
      highlights.push([serviceCrashedStart, time, "cyan"]);
    }
    if (allocFailedStart !== -1) {
      highlights.push([allocFailedStart, time, "lightblue"]);
    }

    const graph = new Dygraph(graphDiv, graphData, {
      height: 800,
      labels: fields,
      highlightCircleSize: 4,
      strokeWidth: 1,
      strokeBorderWidth: 1,
      highlightSeriesOpts:
          {strokeWidth: 2, strokeBorderWidth: 1, highlightCircleSize: 5},
      series: {
        applicationAllocated: {strokeWidth: 4, color: 'black'},
        oom_score: {axis: "y2"},
      },
      axes: {
        x: {drawGrid: false},
        y: {independentTicks: true},
        y2: {valueRange: [0, 1000], independentTicks: true}
      },
      ylabel: 'MB',
      y2label: 'OOM Score',

      underlayCallback: (canvas, area, g) => {
        for (const [start, end, fillStyle] of highlights) {
          canvas.fillStyle = fillStyle;
          canvas.fillRect(g.toDomCoords(start, 0)[0], area.y,
              g.toDomCoords(end, 0)[0] - g.toDomCoords(start, 0)[0], area.h);
        }
      },
      pointClickCallback: (e, p) => {
        alert(p.name);
      },

    });

    graph.ready(() => graph.setAnnotations(annotations));
  }
</script>
</html>
