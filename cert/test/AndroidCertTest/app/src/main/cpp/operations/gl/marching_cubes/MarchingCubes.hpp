/*
 * Copyright 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef marching_cubes_hpp
#define marching_cubes_hpp

#include <ancer/util/UnownedPtr.hpp>
#include <ancer/util/GLHelpers.hpp>

#include "Storage.hpp"

namespace marching_cubes {

/**
 * MaterialState describes the material properties of a point in space; it is
 * expected that implementations of IsoSurfaceValueFunction will compute material
 * state for a point in space (e.g., if describing ground, write "ground-like" material
 * properties).
 */
struct MaterialState {
  // color of fragment
  glm::vec4 color{1};

  // shininess [0,1]
  float shininess{0};

  // amount [0,1] that texture0 will contribute
  float texture0{0};

  // amount [0,1] that texture1 will contribute
  float texture1{0};
};

inline MaterialState mix(const MaterialState &a, const MaterialState &b, float t) {
  return MaterialState{
      glm::mix(a.color, b.color, t),
      glm::mix(a.shininess, b.shininess, t),
      glm::mix(a.texture0, b.texture0, t),
      glm::mix(a.texture1, b.texture1, t)
  };
}

typedef std::function<float(const glm::vec3 &p, MaterialState &)> IsoSurfaceValueFunction;

/**
 * The Vertex type generated by the marching cubes algorithm
 */
struct Vertex {
  glm::vec3 pos;
  glm::vec4 color{1};
  glm::vec3 triangleNormal{0, 1, 0};
  float shininess{0};
  float texture0{0};
  float texture1{0};

  enum class AttributeLayout : GLuint {
    Pos = 0,
    Color = 1,
    TriangleNormal = 2,
    Shininess = 3,
    Texture0 = 4,
    Texture1 = 5
  };

  static void bindVertexAttributes();
};

/**
 * Uses the marching cubes algorithm to triangulate an implicit surface as described by
 * valueSampler.
 *
 * @param region the region to march
 * @param valueSampler a function queried for points in the march region which computes
 * the extent that point is "occupied" by the implicit surface and the material properties at
 * that point in space
 * @param triangleConsumer the triangle consumer receives generated triangles
 */
void march(ancer::glh::iAABB region,
           IsoSurfaceValueFunction valueSampler,
           TriangleConsumer<Vertex> &triangleConsumer);

} // namespace marching_cubes

#endif /* marching_cubes_hpp */
