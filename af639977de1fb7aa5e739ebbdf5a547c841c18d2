{
  "comments": [
    {
      "key": {
        "uuid": "4f2c4125_ab942a00",
        "filename": "include/tuningfork/tuningfork.h",
        "patchSetId": 3
      },
      "lineNbr": 125,
      "author": {
        "id": 1269249
      },
      "writtenOn": "2019-05-20T08:36:28Z",
      "side": 1,
      "message": "Is inlining required to make this work? (i.e. does it prevent deadstripping or something?)\n\nIf not then I\u0027d still be inclined to move the implementation of this call into the .cpp file (along with the macros and _internal call).",
      "revId": "af639977de1fb7aa5e739ebbdf5a547c841c18d2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "998fbcfd_2dac515a",
        "filename": "include/tuningfork/tuningfork.h",
        "patchSetId": 3
      },
      "lineNbr": 125,
      "author": {
        "id": 1498014
      },
      "writtenOn": "2019-05-20T08:52:21Z",
      "side": 1,
      "message": "Having this in the header is required because it forces the compiler consuming the header (the \"consumer\") to generate code that is calling TUNINGFORK_VERSION_SYMBOL, which will resolve to TuningFork_version_x_y (x, y being the version numbers as seen by the \"consumer\"). If these are different from the version numbers used during the compilation of the .a (or .so) (let\u0027s call it the \"vendor\" compiler :)), it will generate a linker error (because the symbol called by the consumer will be undefined).\n\nIf this is moved to the .cpp, both the definition of TuningFork_version_x_y AND the call to TuningFork_version_x_y will be in the same file, compiled at the same time. So no more linker error if you mistmatch the .a and the header file.\n\nI\u0027m not sure there is a cleaner solution - at the end we are forced to have all the needed macros and the call to TUNINGFORK_VERSION_SYMBOL entirely in the header if we want to trigger linker errors in case of mismatch.\nIf it\u0027s too much, the alternative would be to remove all of this and go back to just exporting a symbol which will be enough for analytics.",
      "parentUuid": "4f2c4125_ab942a00",
      "revId": "af639977de1fb7aa5e739ebbdf5a547c841c18d2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "170ee94c_fc0132db",
        "filename": "include/tuningfork/tuningfork.h",
        "patchSetId": 3
      },
      "lineNbr": 125,
      "author": {
        "id": 1373878
      },
      "writtenOn": "2019-05-20T09:00:06Z",
      "side": 1,
      "message": "Like Florian says, we wouldn\u0027t get link-time checking of header/library compatibility without some header shenanigans. Maybe we\u0027re over-thinking it though and we shouldn\u0027t worry too much about this check? Most libraries don\u0027t do it explicitly.",
      "parentUuid": "4f2c4125_ab942a00",
      "revId": "af639977de1fb7aa5e739ebbdf5a547c841c18d2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c32a68ec_f53341b9",
        "filename": "include/tuningfork/tuningfork.h",
        "patchSetId": 3
      },
      "lineNbr": 125,
      "author": {
        "id": 1373878
      },
      "writtenOn": "2019-05-24T10:12:26Z",
      "side": 1,
      "message": "We decided to keep the macros and inline function in the header in the end. They do provide some utility to developers.",
      "parentUuid": "170ee94c_fc0132db",
      "revId": "af639977de1fb7aa5e739ebbdf5a547c841c18d2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}