{
  "comments": [
    {
      "key": {
        "uuid": "13b7d06a_de9e274b",
        "filename": "src/swappy/common/ChoreographerThread.cpp",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1388190
      },
      "writtenOn": "2020-01-10T18:27:39Z",
      "side": 1,
      "message": "Why do we need this change ? It is better to call ALooper_wake(mLooper) to signal exit instead of waking up every now and then.\nWe are probably missing a wake somewhere.",
      "revId": "cd35988e0e7129decd22c77cd2ffc8ce75dd2379",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7940d6ec_d042f771",
        "filename": "src/swappy/common/ChoreographerThread.cpp",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1373878
      },
      "writtenOn": "2020-01-10T23:54:04Z",
      "side": 1,
      "message": "If you look in the bug https://b.corp.google.com/issues/147411622 you\u0027ll see the issue that the user was reporting. Maybe they are not using the API correctly or maybe we are missing a wake, but having an infinite wait here seems to be asking for trouble.",
      "parentUuid": "13b7d06a_de9e274b",
      "revId": "cd35988e0e7129decd22c77cd2ffc8ce75dd2379",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fab1834_d2995be1",
        "filename": "src/swappy/common/ChoreographerThread.cpp",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1388190
      },
      "writtenOn": "2020-01-11T00:08:06Z",
      "side": 1,
      "message": "based on the bug we have a race condition between ~NDKChoreographerThread() and looperThread()\n\nWhat if we change ~NDKChoreographerThread() to:\n\nNDKChoreographerThread::~NDKChoreographerThread()\n{\n    ALOGI(\"Destroying NDKChoreographerThread\");\n\n    if (mLibAndroid !\u003d nullptr)\n      dlclose(mLibAndroid);\n\n    {\n        std::lock_guard\u003cstd::mutex\u003e lock(mWaitingMutex);\n    \n        if (!mLooper) {\n            return;\n        }\n\n        ALooper_acquire(mLooper);\n        mThreadRunning \u003d false;\n        ALooper_wake(mLooper);\n    }\n    mThread.join();\n    ALooper_release(mLooper);\n}",
      "parentUuid": "7940d6ec_d042f771",
      "revId": "cd35988e0e7129decd22c77cd2ffc8ce75dd2379",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}