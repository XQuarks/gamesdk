import com.google.androidgamesdk.BuildFolders
import com.google.androidgamesdk.BuildOptions
import com.google.androidgamesdk.SpecificToolchain
import com.google.androidgamesdk.LocalToolchain
import com.google.androidgamesdk.Toolchain
import com.google.androidgamesdk.NativeLibrary
import com.google.androidgamesdk.NativeLibrary.SampleFolder

import java.nio.file.Paths
import org.gradle.internal.logging.text.StyledTextOutputFactory;
import static org.gradle.internal.logging.text.StyledTextOutput.Style;
import org.gradle.internal.os.OperatingSystem;
import static groovy.lang.Closure.IDENTITY;
import groovyx.gpars.GParsPool;
import org.apache.tools.ant.filters.ReplaceTokens;
import com.google.androidgamesdk.ExternalToolName;
import static com.google.androidgamesdk.OsSpecificTools.osFolderName;
import static com.google.androidgamesdk.CMakeWrapper.runAndroidCMake;
import static com.google.androidgamesdk.CMakeWrapper.runHostCMake;

buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.2'
        classpath "org.codehaus.gpars:gpars:1.2.0"
    }
}

defaultTasks 'cleanPath', 'archiveZip'

def joinPath(String first, String... more) {
    return Paths.get(first, more).toString()
}

def swappyNativeLibrary = new NativeLibrary('swappy', 'GAMESDK_BUILD_SWAPPY')
        .setAarLibrary("gaming-frame-pacing", "1.5.0")
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', "bouncyball")))
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', "cube")))
        .addSampleAndroidProject(new SampleFolder(joinPath('third_party', "cube")))
def tuningForkNativeLibrary = new NativeLibrary('tuningfork', 'GAMESDK_BUILD_TUNINGFORK')
        .setAarLibrary("gaming-performance-tuner", "1.0.0")
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', 'tuningfork', 'insightsdemo')))
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', 'tuningfork', 'experimentsdemo')))
        .addSampleAndroidProject(new SampleFolder(joinPath('src', 'tuningfork', 'tools', 'validation')))
        .addSampleExtraFolder(new SampleFolder(joinPath('samples', 'tuningfork', "common")))
        .addSampleExtraFolder(new SampleFolder(joinPath('src', 'protobuf')))
        .addSampleExtraFolder(new SampleFolder(joinPath('third_party', 'protobuf-3.0.0')))
        .addSampleExtraFolder(new SampleFolder(joinPath('..', 'external', 'nanopb-c'), joinPath('external', 'nanopb-c')))
        .addSampleExtraFolder(new SampleFolder(joinPath('src', 'tuningfork', 'proto')).include('tuningfork.proto'))

def protobufInstallDir() {
    return new File("$projectDir/third_party/protobuf-3.0.0/install/"
        + osFolderName(ExternalToolName.PROTOBUF)).getPath()
}

def getEnvironment() {
    def env = [:]
    def trans = IDENTITY
    if (OperatingSystem.current().isWindows()) {
        trans = { it.toUpperCase() }
    }
    System.getenv().each{entry -> env[trans(entry.key)] = entry.value}
    return env
}

task prepare_proto_before {
    def protocBinDir = protobufInstallDir() + "/bin"
    def env = getEnvironment()
    env['PATH'] = protocBinDir + System.getProperty("path.separator") + env['PATH']
    doLast {
        // Install python-protobuf
        exec {
            workingDir "./third_party/protobuf-3.0.0/python"
            setEnvironment env
            commandLine "python", "setup.py", "install", "--user"
        }
        // Generate nano-pb requirements
        exec {
            workingDir '../external/nanopb-c/generator/proto'
            setEnvironment env
            commandLine 'make'
        }
    }
}

task prepare_proto(dependsOn: prepare_proto_before) {
    doLast {
        exec {
            commandLine "python"
            args = ["ab_info.py"]
        }
    }
}


allprojects {
    buildDir = getOutPath()
    repositories {
        google()
        jcenter()
    }
}

def allLibraries = [swappyNativeLibrary, tuningForkNativeLibrary]

def getBuildPath() {
    return new File("$projectDir/build").getPath()
}

def getOutPath() {
    return new File("$projectDir/../out").getPath()
}

def getPackagePath() {
    return new File("$projectDir/../package").getPath();
}

def getDistPath() {
    def distDir = System.getenv('DIST_DIR');
    if (distDir != null) {
        return new File(distDir).getPath();
    }
    else {
        return getPackagePath();
    }
}

def getTempPath() {
    return new File("$projectDir/../.temp").getPath()//.getAbsolutePath()
}


def buildHostModule(subdir, buildType) {
    def toolchain = getLocalToolchain()
    def buildKey = "host"
    def workingFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def outputFolder = joinPath(getOutPath(), buildKey)
    def cmakeProjectFolder = joinPath("$projectDir", subdir)
    def buildFolders = new BuildFolders(cmakeProjectFolder, workingFolder, outputFolder)

    runHostCMake(project, buildFolders, toolchain, buildType)

    def cmdLine = ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }
    return [buildKey: buildKey, outputFolder: outputFolder]
}

def buildNativeModules(BuildOptions buildOptions, Toolchain toolchain, Collection<NativeLibrary> libraries, subdir) {
    def buildKey = toolchain.getBuildKey(buildOptions)

    def workingFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def outputFolder = joinPath(getOutPath(), buildKey)
    def cmakeProjectFolder = joinPath("$projectDir", subdir)
    def buildFolders = new BuildFolders(cmakeProjectFolder, workingFolder, outputFolder)

    runAndroidCMake(project, buildFolders, toolchain, buildOptions, libraries)

    def cmdLine = !toolchain.getNinjaPath().isEmpty() ? [toolchain.getNinjaPath()] : ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }

    def jsonDescription = new File(joinPath(outputFolder, "abi.json"))
    jsonDescription.text = '{"abi":"'+buildOptions.arch+'","api":'+toolchain.getAndroidVersion()+
        ',"ndk":'+toolchain.getNdkVersionNumber()+',"stl":"'+buildOptions.stl+'"}'

    return [arch: buildOptions.arch, buildKey: buildKey]
}

task cleanPath(type: Delete) {
    delete getOutPath()
    delete getPackagePath()
    delete getTempPath()
    delete getBuildPath()
}

def executeCmd(cmd, dir) {
    def out = new StringBuilder()
    def err = new StringBuilder()
    def process = cmd.execute(null, new File(dir))
    process.consumeProcessOutput(out, err)
    process.waitFor()
    logger.info("Runnig $cmd")
    if(out.length()>0)
        logger.info(out.toString())
    if(err.length()>0)
        logger.error(err.toString())
}

// Create outAr from the contents of inArs
// All files taken/created in dir
def repackArchives(dir, inArs, outAr) {
    def arPath = getLocalToolchain().getArPath()
    if (OperatingSystem.current().isWindows()) {
        inArs.each {
            executeCmd("cmd /c ${arPath} -x ${it}", dir)
        }
        executeCmd("cmd /c for %i in (*.o) do ${arPath} -rcs ${outAr} %i", dir)
        executeCmd("cmd /c del *.o", dir)
    }  else {
        def cmd = /pushd $dir &&/
        inArs.each {
            cmd <<= /$arPath -x $it &&/
        }
        cmd <<= /$arPath -rcs $outAr *.o && rm *.o && popd/
        ['/bin/bash', '-c', cmd.toString()].execute().waitFor()
    }
}

def copyLibraryToPrefabAar(buildInfo, outFolder, library) {
    def libraryName = library.nativeLibraryName
    def prefabName = library.aarLibraryName
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = joinPath(getTempPath(), buildKey, '.cmake', libraryName)
    def buildFolder = joinPath(getPackagePath(), outFolder)
    def sharedLibBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName, 'libs',
                                  'android.'+buildKey)
    def staticLibBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName + '_static', 'libs',
                                  'android.'+buildKey)
    def staticsFolder = joinPath(getOutPath(), buildKey)
    def sharedIncludeBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName, 'include', libraryName)
    def staticIncludeBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName + '_static', 'include', libraryName)
    def headerFolder = './include/' + libraryName

    // TODO: including the dynamic library (uncommenting these next lines)
    // errors because no proper library can be found for module swappy (the shared version),
    // probably because we're using c++_static in samples?
    def buildSharedLibrary = false
    def buildStaticLibrary = true

    // 1. Copy dynamic library
    if (buildSharedLibrary) {
        copy {
            from file(cmakeFolder)
            include "*.so"
            into file(sharedLibBuildFolder)
            includeEmptyDirs = false
        }
        copy {
            from file(staticsFolder)
            include "*.json"
            into file(sharedLibBuildFolder)
        }
    }
    // 2. Copy the static libary
    if (buildStaticLibrary) {
        copy {
            from file(staticsFolder)
            include("lib" + libraryName + "_static.a", "*.json")
            rename("lib" + libraryName + "_static.a", "lib" + libraryName + ".a")
            into file(staticLibBuildFolder)
        }
    }
    // 3.1 Copy headers (shared library)
    if (buildSharedLibrary) {
        copy {
            from file(headerFolder)
            include "*.h"
            into file(sharedIncludeBuildFolder)
            includeEmptyDirs = false
        }
    }
    // 3.2 Copy headers (static library)
    if (buildStaticLibrary) {
        copy {
            from file(headerFolder)
            include "*.h"
            into file(staticIncludeBuildFolder)
            includeEmptyDirs = false
        }
    }
    // 4. Copy the manifest
    copy {
        from file("./src")
        include "AndroidManifest.xml"
        into file(buildFolder)
        includeEmptyDirs = false
    }
    // 5. Create the json files
    def jsonPrefabDescription = new File(joinPath(buildFolder, 'prefab', 'prefab.json'))
    jsonPrefabDescription.text = '{"name":"' + prefabName + '","schema_version":1,"dependencies":[],"version":"1.3.0"}'
    if (buildSharedLibrary) {
        def jsonModuleDescription = new File(joinPath(buildFolder, 'prefab', 'modules', libraryName, 'module.json'))
        jsonModuleDescription.text = '{"library_name": "lib' + libraryName + '", "export_libraries": []}'
    }
    if (buildStaticLibrary) {
        def jsonStaticModuleDescription = new File(joinPath(buildFolder, 'prefab', 'modules', libraryName + '_static', 'module.json'))
        jsonStaticModuleDescription.text = '{"library_name": "lib' + libraryName + '", "export_libraries": []}'
    }
}

def sdkCopy(buildInfo, outFolder, Collection<NativeLibrary> libraries, staticToo = false,
            useFullBuildKey = false, flattenLibDirs = false, shared = true) {
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def buildFolder = joinPath(getPackagePath(), outFolder)
    def libBuildFolder = joinPath(buildFolder, 'libs',
                                  useFullBuildKey ? buildKey : arch, 'lib')

    if (shared) {
        libraries.forEach({ nativeLibrary ->
            copy {
                from file(cmakeFolder)
                include nativeLibrary.nativeLibraryName + "*/lib*.so"
                into file(libBuildFolder)
                includeEmptyDirs = false
                if (flattenLibDirs) {
                    eachFile {
                        path = name
                    }
                }
            }
        })
    }
    if (staticToo) {
        def staticsFolder = joinPath(getOutPath(), buildKey)
        def staticLibsBuildFolder = joinPath(buildFolder, 'libs', buildKey)
        def staticLibs = []
        libraries.forEach({nativeLibrary ->
            staticLibs += "lib" + nativeLibrary.nativeLibraryName + "_static.a"
        })
        repackArchives(staticsFolder, staticLibs, 'libgamesdk.a')
        copy {
            from file(staticsFolder)
            include "libgamesdk.a"
            into file(staticLibsBuildFolder)
        }
    }
}

def copyExtras(outFolder, Collection<NativeLibrary> libraries) {
    def buildFolder = getPackagePath() + '/' + outFolder
    def headerFolder = './include'
    def aarFolder = joinPath(getOutPath(), 'outputs', 'aar')
    def includeBuildFolder = joinPath(buildFolder, 'include')
    def aarBuildFolder = joinPath(buildFolder, 'aar')

    libraries.forEach({ nativeLibrary ->
        copy {
            from file(headerFolder)
            include nativeLibrary.nativeLibraryName + "*/*.h"
            into file(includeBuildFolder)
            includeEmptyDirs = false
        }
    })
    copy {
        from file(aarFolder)
        into file(aarBuildFolder)
        includeEmptyDirs = false
    }
}

def copyDocs(outFolder) {
    copy {
        from "LICENSE", "THIRD_PARTY_NOTICES", "RELEASE_NOTES"
        into getPackagePath() + '/' + outFolder
    }
}

// Copy samples for packaging. Also rename CMakeLists.txt files so that the
// one distributed are using the packaged game sdk.
def copySamples(outFolder, Collection<NativeLibrary> libraries) {
    def buildFolder = getPackagePath() + '/' + outFolder

    // CMake utility for the Game SDK
    copy {
        from file(joinPath('samples', "gamesdk.cmake"))
        into file(joinPath(buildFolder, 'samples'))
    }

    // All sample common files
    copy {
        from file(joinPath('samples', "common"))
        into file(joinPath(buildFolder, 'samples', 'common'))
    }

    // Library specific files
    libraries.forEach({ nativeLibrary ->
        nativeLibrary.sampleAndroidProjectPaths.forEach({sampleFolder ->
            copy {
                from file(sampleFolder.sourcePath)
                into file(joinPath(buildFolder, sampleFolder.destinationPath))
                exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild", "**/.gradle",
                        "**/OWNERS", "**/.idea", '**/CMakeLists.txt'
                rename 'CMakeLists.for-samples-in-archive.txt', 'CMakeLists.txt'
                includeEmptyDirs = false
            }
        })

        nativeLibrary.sampleExtraFolderPaths.forEach({sampleFolder ->
            copy {
                from file(sampleFolder.sourcePath)
                into file(joinPath(buildFolder, sampleFolder.destinationPath))
                if (sampleFolder.includePattern != null) {
                    include sampleFolder.includePattern
                }
                includeEmptyDirs = false
            }
        })
    })
}

def abis32Bits() { return ["armeabi-v7a", "x86"] }
def abis64Bits() { return ["arm64-v8a", "x86_64"] }
def defaultAbis() { return abis32Bits() + abis64Bits() }
def allSTLs() { return ["c++_static", "c++_shared", "gnustl_static", "gnustl_shared"] }
def post17STLs() { return ["c++_static", "c++_shared"] }
def versionMapping() { return [ [["r14"], [14,15,16,17,18,19,20,21,22,23,24]],
                               [["r15"], [14,15,16,17,18,19,21,22,23,24,26]],
                               [["r16"], [14,15,16,17,18,19,21,22,23,24,26,27]],
                               [["r17"], [14,15,16,17,18,19,21,22,23,24,26,27,28]]] }
def versionMappingPost17() { return [ [["r18"], [16,17,18,19,21,22,23,24,26,27,28]],
                               [["r19"], [16,17,18,19,21,22,23,24,26,27,28]],
                               [["r20"], [16,17,18,19,21,22,23,24,26,27,28]],
                               [["r21"], [16,17,18,19,21,22,23,24,26,27,28,29]]] }

def unityNativeBuild(libraries, buildType="Release") {
    def threadChecks = false
    return defaultAbis().collect {
        buildNativeModules(
                new BuildOptions(buildType, threadChecks,  "c++_static", it),
                new SpecificToolchain(project, "21", "r19"),
                libraries,
                "src")
    }
}

def sdkNativeBuild(libraries, buildType="Release") {
    def threadChecks = false

    def versions = versionMapping().collectMany { GroovyCollections.combinations(it) }
    def versionsPost17 = versionMappingPost17().collectMany { GroovyCollections.combinations(it) }
    def allCombos = GroovyCollections.combinations(defaultAbis(), versions, allSTLs()) +
        GroovyCollections.combinations(defaultAbis(), versionsPost17, post17STLs());
    GParsPool.withPool {
        return allCombos.collectParallel { x ->
            def arch = x[0];
            def stl = x[2];
            buildNativeModules(
                    new BuildOptions(buildType, threadChecks, stl, arch),
                    new SpecificToolchain(
                            project,
                            /*androidVersion=*/ x[1][1].toString(),
                            /*ndkVersion=*/ x[1][0]
                    ),
                    libraries,
                    "src")
        }
    }
}

// For the AAR, only build the dynamic libraries against shared STL.
def aarSTLs() { return ["c++_shared", "gnustl_shared"] }
def aarPost17STLs() { return ["c++_shared"] }

// In the AAR, library search is handled by Prefab, that looks for API 21 for 64 bits architectures
// even if a lower API level is requested. We need to build a different set of libraries for 32 and
// 64 bits as a consequence.
def aarVersionMapping32Bits() { return versionMapping() }
def aarVersionMapping32BitsPost17() { return versionMappingPost17() }
def aarVersionMapping64Bits() { return [ [["r14"], [21,22,23,24]],
                               [["r15"], [21,22,23,24,26]],
                               [["r16"], [21,22,23,24,26,27]],
                               [["r17"], [21,22,23,24,26,27,28]]] }
def aarVersionMapping64BitsPost17() { return [ [["r18"], [21,22,23,24,26,27,28]],
                               [["r19"], [21,22,23,24,26,27,28]],
                               [["r20"], [21,22,23,24,26,27,28]],
                               [["r21"], [21,22,23,24,26,27,28,29]]] }

def sdkAarNativeBuild(libraries, buildType) {
    def threadChecks = false

    def versions32Bits = aarVersionMapping32Bits().collectMany { GroovyCollections.combinations(it) }
    def versions32BitsPost17 = aarVersionMapping32BitsPost17().collectMany { GroovyCollections.combinations(it) }
    def versions64Bits = aarVersionMapping64Bits().collectMany { GroovyCollections.combinations(it) }
    def versions64BitsPost17 = aarVersionMapping64BitsPost17().collectMany { GroovyCollections.combinations(it) }
    def allCombos =
        GroovyCollections.combinations(abis32Bits(), versions32Bits, aarSTLs()) +
        GroovyCollections.combinations(abis32Bits(), versions32BitsPost17, aarPost17STLs()) +
        GroovyCollections.combinations(abis64Bits(), versions64Bits, aarSTLs()) +
        GroovyCollections.combinations(abis64Bits(), versions64BitsPost17, aarPost17STLs());
    GParsPool.withPool {
        return allCombos.collectParallel { x ->
            def arch = x[0]
            def stl = x[2]
            buildNativeModules(
                    new BuildOptions(buildType, threadChecks, stl, arch),
                    new SpecificToolchain(
                            project,
                            /*androidVersion=*/ x[1][1].toString(),
                            /*ndkVersion=*/ x[1][0]
                    ),
                    libraries,
                    "src")
        }
    }
}

def specificNativeBuild(sdkVersion, ndkVersion, stlVersion, libraries,
                        buildType="Release") {
    def threadChecks = false

    def toolchain = new SpecificToolchain(project, sdkVersion, ndkVersion)
    return defaultAbis().collect {
        buildNativeModules(
                new BuildOptions(buildType, threadChecks, stlVersion, it),
                toolchain,
                libraries,
                "src")
    }
}

def getLocalToolchain() {
    def kApiLevel = project.hasProperty("androidApiLevel") ?
        project.androidApiLevel : "24"
    return new LocalToolchain(project, kApiLevel)
}

def localNativeBuild(libraries, subdir = "src", buildType="Release") {
    def toolchain = getLocalToolchain();
    def threadChecks = true
    return defaultAbis().collect {
        def buildOptions = new BuildOptions(buildType, threadChecks, "c++_static", it)
        buildNativeModules(buildOptions, toolchain, libraries, subdir)
    }
}

def getBuildType() {
    return project.hasProperty("buildType") ?
        project.buildType : "Release"
}

def getPackageName() {
    return project.hasProperty("packageName") ?
            project.packageName : "gamesdk"
}

def shouldIncludeSamples() {
    return project.hasProperty("includeSamples") ?
        project.includeSamples : false
}

def getLibraries(allLibraries) {
    if (!project.hasProperty("libraries")) {
        throw new GradleException("""
Must specify which libraries to build,
e.g. ./gradlew build -Plibraries=swappy,tuningfork""")
    }

    def requestedLibraryNames = project.libraries.split(',');
    return requestedLibraryNames.collect { requestedLibraryName ->
        def library = allLibraries.find {
            library -> library.nativeLibraryName == requestedLibraryName
        }
        if (library == null) {
            throw new GradleException("Library ${requestedLibraryName} does not exist.")
        }
        
        return library
    }
}

class BuildTask extends DefaultTask {
}

task build(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> sdkNativeBuild(libraries, bt) }
}

task buildUnity(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = getPackageName()
    ext.flattenLibs = true
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> unityNativeBuild(libraries, bt) }
}

task buildAar(type: BuildTask) {
    doFirst {
        // Clear the package path to ensure AAR generation is not polluted
        // by previous build tasks.
        delete getPackagePath()
    }
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> sdkAarNativeBuild(libraries, bt) }
    doLast {
        nativeBuild(libraries, buildType).each { buildInfo ->
            libraries.forEach { library -> copyLibraryToPrefabAar(buildInfo, packageName, library) }
        }
    }
}

task buildLocal(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries);
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = false
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> localNativeBuild(libraries, "src", bt) }
}

task buildSpecific(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = false
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt ->
        def sdk = System.getenv("SDK")
        def ndk = System.getenv("NDK")
        def stl = System.getenv("STL")
        if (sdk==null || ndk==null || stl==null) {
            throw new GradleException("""
Must set SDK, NDK and STL for a specific build,
e.g. SDK=14 NDK=r16 STL='c++_static' ./gradlew specificZip"""
            )
        }
        specificNativeBuild(sdk, ndk, stl, libraries, bt)
    }
}

// Just build swappy shared libraries
//task swappyUnityBuild(type: BuildTask) {
// ./gradlew buildUnity --Plibraries=swappy --PpackageName=swappyUnity

//task swappyUnityDebugBuild(type: BuildTask) {
// ./gradlew buildUnity -PbuildType=Debug --Plibraries=swappy --PpackageName=swappyUnity

// Full build including tuning fork for unity, shared libraries only
//task unityBuild(type: BuildTask) {
// ./gradlew buildUnity --Plibraries=swappy,tuningfork --PpackageName=unity

// Build everything
//task fullSdkBuild(type: BuildTask) {
// ./gradlew build --Plibraries=swappy,tuningfork --PpackageName=fullsdk --PincludeSamples=true

// Build everything without TF
//task releaseSdkBuild(type: BuildTask) {
// ./gradlew build --Plibraries=swappy --PincludeSamples=true

// Build everything in debug without TF
//task debugSdkBuild(type: BuildTask) {
// ./gradlew build =PbuildType=Debug --Plibraries=swappy --PincludeSamples=true

//task gamingFramePacingAarSdkBuild() {
// ./gradlew buildAar -Plibraries=swappy -PincludeSamples=true

//task gamingFramePacingAarFullSdkBuild() {
// ./gradlew buildAar -Plibraries=swappy -PpackageName=fullsdk -PincludeSamples=true

//task gamingPerformanceTunerAarFullSdkBuild() {
// ./gradlew buildAar -Plibraries=tuningfork -PpackageName=fullsdk -PincludeSamples=true


// Build using local SDK, no tuning fork
//task localBuild(type: BuildTask) {
// ./gradlew buildLocal -Plibraries=swappy -PpackageName=local

// Build using local SDK, with tuning fork
//task localTfBuild(type: BuildTask) {
// ./gradlew buildLocal -Plibraries=swappy,tuningfork -PpackageName=localtf

//task specificBuild(type: BuildTask) {
// SDK=14 NDK=r16 STL='c++_static' ./gradlew buildSpecific -Plibraries=swappy,tuningfork -PpackageName=specific --PincludeSamples=true

tasks.withType(BuildTask) {
    doLast {
        // Clear the package path to ensure the task zip is not polluted
        // by previous build tasks.
        delete getPackagePath()
        nativeBuild(libraries, buildType).each {
            sdkCopy(it, packageName, libraries, withStaticLibs,
                    withFullBuildKey, flattenLibs, withSharedLibs)
        }
        copyExtras(packageName, libraries)

        copyDocs(packageName)

        if (withSamples) {
            copySamples(packageName, libraries)
        }
    }
}

task localUnitTests {
    // These unit tests require a connected ARM64 device to run
    doLast {
        def buildInfo = localNativeBuild([swappyNativeLibrary, tuningForkNativeLibrary], "test/tuningfork")
        def buildKey = buildInfo.buildKey.findAll{it.contains('arm64-v8a')}[0]
        def cmakeFolder = getTempPath() + '/' + buildKey + '/.cmake'
        def toolchain = getLocalToolchain();
        def adb = toolchain.getAdbPath();
        exec {
            workingDir cmakeFolder
            commandLine adb, "push", "tuningfork_test", "/data/local/tmp"
        }
        exec {
            workingDir cmakeFolder
            commandLine adb, "shell", "/data/local/tmp/tuningfork_test"
        }
    }
}

task localSwappyUnitTests {
    // These unit tests require a connected ARM64 device to run
    doLast {
        def buildInfo = localNativeBuild([swappyNativeLibrary], "test/swappy")
        def buildKey = buildInfo.buildKey.findAll{it.contains('arm64-v8a')}[0]
        def cmakeFolder = getTempPath() + '/' + buildKey + '/.cmake'
        def toolchain = getLocalToolchain();
        def adb = toolchain.getAdbPath();
        exec {
            workingDir cmakeFolder
            commandLine adb, "push", "swappy_test", "/data/local/tmp"
        }
        exec {
            workingDir cmakeFolder
            commandLine adb, "shell", "/data/local/tmp/swappy_test"
        }
    }
}

task localDeviceInfoUnitTests {
    doLast {
        def buildInfo = buildHostModule("test/device_info", "Release")
        exec {
            workingDir buildInfo.outputFolder
            commandLine "./device_info_test"
        }
    }
}

task format {
    doLast {
        def formattedFiles =
            fileTree(dir: 'src', include: ['**/*.cpp', '**/*.c', '**/*.h'], excludes: ["protobuf"]) +
            fileTree(dir: 'include', include: ['**/*.h'], excludes: ["third_party"])

        formattedFiles.files.each { file ->
            exec {
                commandLine "/bin/bash"
                args "-c", "clang-format -i " + file
                workingDir projectDir
            }
        }
    }
}

// Zipping things up
def addZipTask(name, buildTask, archName) {
    def packPath = buildTask.packageName
    tasks.register(name, Zip) {
        dependsOn buildTask
        def buildFolder = joinPath(getPackagePath(), packPath)

        from fileTree(buildFolder)
        exclude archName
        destinationDirectory = file(buildFolder)
        archiveFileName = archName

        doLast {
            def outFolder = getBuildPath();
            mkdir outFolder;

            copy {
                from file(archiveName)
                into outFolder
            }

            if (getDistPath() != getPackagePath()) {
                copy {
                    from getPackagePath()
                    into getDistPath()
                }
            }

            def out = services.get(StyledTextOutputFactory).create("output")
            out.style(Style.Identifier).text('\n' + archName +' is in ')
            .style(Style.ProgressStatus)
                .println(destinationDirectory.get());
        }
    }

}

// Generate a zip file with the library AAR and its pom file, all versioned,
// so that it's ready to be uploaded to Maven.
def addAarMavenZipTask(name, aarBuildTask) {
    def packPath = "fullsdk"
    def buildFolder = joinPath(getPackagePath(), packPath)
    def mavenZipContentFolder = joinPath(buildFolder, libraryName + "-maven-zip");

    // After building the AAR, prepare the versioned pom file and AAR file.
    tasks.register("prepareMavenZipContentFor" + name) {
        dependsOn aarBuildTask

        doLast {
            delete mavenZipContentFolder
            mkdir mavenZipContentFolder

            getLibraries(allLibraries).forEach {nativeLibrary ->
                def libraryName = nativeLibrary.aarLibraryName
                def aarVersion = nativeLibrary.aarVersion

                copy {
                    from file(joinPath(buildFolder, "gamesdk.aar")) //TODO
                    into file(joinPath(mavenZipContentFolder))
                    rename "gamesdk.aar", libraryName + "-" + aarVersion + ".aar"
                }

                copy {
                    from file(joinPath("src", "maven", libraryName + ".pom"))
                    into file(joinPath(mavenZipContentFolder))
                    rename libraryName + ".pom", libraryName + "-" + aarVersion + ".pom"
                    filter(ReplaceTokens, tokens: [aarVersion: aarVersion])
                }
            }
        }
    }

    // Create a zip for upload to Maven.
    tasks.register(name, Zip) {
        dependsOn "prepareMavenZipContentFor" + name

        from fileTree(mavenZipContentFolder)
        destinationDirectory = file(buildFolder)
        def aarName = getLibraries(allLibraries).collect { it.aarLibraryName }.join('-')
        archiveFileName = aarName + "-maven-zip.zip"

        // Don't lose time compressing already compressed files
        entryCompression = ZipEntryCompression.STORED

        doLast {
            if (getDistPath() != getPackagePath()) {
                copy {
                    from getPackagePath()
                    into getDistPath()
                }
            }
        }
    }
}

addZipTask("packageUnityZip", buildUnity, "builds.zip")
addZipTask("packageZip", build, "gamesdk.zip")
addZipTask("packageLocalZip", buildLocal, "gamesdk.zip")
addZipTask("packageSpecificZip", buildSpecific, "gamesdk.zip")

addZipTask("packageAar", buildAar, "gamesdk.aar")
addAarMavenZipTask("packageMavenZip", "packageAar")

// packageUnityZip
//addZipTask("swappyUnityZip", swappyUnityBuild, "builds")
//addZipTask("swappyUnityDebugZip", swappyUnityDebugBuild, "builds")
//addZipTask("unityZip", unityBuild, "builds")

// packageZip
//addZipTask("archiveZip", localBuild, "gamesdk")
//addZipTask("archiveTfZip", localTfBuild, "gamesdk")
//addZipTask("fullSdkZip", fullSdkBuild, "gamesdk")
//addZipTask("specificZip", specificBuild, "gamesdk")
//addZipTask("gamesdkZip", releaseSdkBuild, "gamesdk")
//addZipTask("gamesdkDebugZip", debugSdkBuild, "gamesdk_debug")

// packageAar
//addZipTask("gamingFramePacingAar", gamingFramePacingAarSdkBuild, "gaming-frame-pacing.aar")
//addZipTask("fullSdkGamingFramePacingAar", gamingFramePacingAarFullSdkBuild, "gaming-frame-pacing.aar")
//addZipTask("fullSdkGamingPerformanceTunerAar", gamingPerformanceTunerAarFullSdkBuild, "gaming-performance-tuner.aar")
//addAarMavenZipTask("fullSdkGamingFramePacingAarMavenZip", "fullSdkGamingFramePacingAar",
//    "gaming-frame-pacing", "1.5.0-alpha01")
//addAarMavenZipTask("fullSdkGamingPerformanceTunerAarMavenZip", "fullSdkGamingPerformanceTunerAar",
//    "gaming-performance-tuner", "1.0.0-alpha01")
