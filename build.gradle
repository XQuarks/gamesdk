import com.google.androidgamesdk.BuildFolders
import com.google.androidgamesdk.BuildOptions
import com.google.androidgamesdk.SpecificToolchain
import com.google.androidgamesdk.LocalToolchain
import com.google.androidgamesdk.Toolchain
import com.google.androidgamesdk.NativeLibrary
import com.google.androidgamesdk.NativeLibrary.SampleFolder
import com.google.androidgamesdk.ToolchainEnumerator

import java.nio.file.Paths
import org.gradle.internal.logging.text.StyledTextOutputFactory;
import static org.gradle.internal.logging.text.StyledTextOutput.Style;
import org.gradle.internal.os.OperatingSystem;
import static groovy.lang.Closure.IDENTITY;
import groovyx.gpars.GParsPool;
import org.apache.tools.ant.filters.ReplaceTokens;
import com.google.androidgamesdk.ExternalToolName;
import static com.google.androidgamesdk.OsSpecificTools.osFolderName;
import static com.google.androidgamesdk.CMakeWrapper.runAndroidCMake;
import static com.google.androidgamesdk.CMakeWrapper.runHostCMake;

buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.2'
        classpath "org.codehaus.gpars:gpars:1.2.0"
    }
}

def joinPath(String first, String... more) {
    return Paths.get(first, more).toString()
}

def swappyNativeLibrary = new NativeLibrary('swappy', 'GAMESDK_BUILD_SWAPPY')
        .setAarLibrary("gaming-frame-pacing", "1.5.0")
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', "bouncyball")))
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', "cube")))
        .addSampleAndroidProject(new SampleFolder(joinPath('third_party', "cube")))
def tuningForkNativeLibrary = new NativeLibrary('tuningfork', 'GAMESDK_BUILD_TUNINGFORK')
        .setAarLibrary("gaming-performance-tuner", "1.0.0")
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', 'tuningfork', 'insightsdemo')))
        .addSampleAndroidProject(new SampleFolder(joinPath('samples', 'tuningfork', 'experimentsdemo')))
        .addSampleAndroidProject(new SampleFolder(joinPath('src', 'tuningfork', 'tools', 'validation')))
        .addSampleExtraFolder(new SampleFolder(joinPath('samples', 'tuningfork', "common")))
        .addSampleExtraFolder(new SampleFolder(joinPath('src', 'protobuf')))
        .addSampleExtraFolder(new SampleFolder(joinPath('third_party', 'protobuf-3.0.0')))
        .addSampleExtraFolder(new SampleFolder(joinPath('..', 'external', 'nanopb-c'), joinPath('external', 'nanopb-c')))
        .addSampleExtraFolder(new SampleFolder(joinPath('src', 'tuningfork', 'proto')).include('tuningfork.proto'))

def protobufInstallDir() {
    return new File("$projectDir/third_party/protobuf-3.0.0/install/"
        + osFolderName(ExternalToolName.PROTOBUF)).getPath()
}

def getEnvironment() {
    def env = [:]
    def trans = IDENTITY
    if (OperatingSystem.current().isWindows()) {
        trans = { it.toUpperCase() }
    }
    System.getenv().each{entry -> env[trans(entry.key)] = entry.value}
    return env
}

task prepare_proto_before {
    def protocBinDir = protobufInstallDir() + "/bin"
    def env = getEnvironment()
    env['PATH'] = protocBinDir + System.getProperty("path.separator") + env['PATH']
    doLast {
        // Install python-protobuf
        exec {
            workingDir "./third_party/protobuf-3.0.0/python"
            setEnvironment env
            commandLine "python", "setup.py", "install", "--user"
        }
        // Generate nano-pb requirements
        exec {
            workingDir '../external/nanopb-c/generator/proto'
            setEnvironment env
            commandLine 'make'
        }
    }
}

task prepare_proto(dependsOn: prepare_proto_before) {
    doLast {
        exec {
            commandLine "python"
            args = ["ab_info.py"]
        }
    }
}


allprojects {
    buildDir = getOutPath()
    repositories {
        google()
        jcenter()
    }
}

def allLibraries = [swappyNativeLibrary, tuningForkNativeLibrary]

def getBuildPath() {
    return new File("$projectDir/build").getPath()
}

def getOutPath() {
    return new File("$projectDir/../out").getPath()
}

def getPackagePath() {
    return new File("$projectDir/../package").getPath();
}

def getDistPath() {
    def distDir = System.getenv('DIST_DIR');
    if (distDir != null) {
        return new File(distDir).getPath();
    }
    else {
        return getPackagePath();
    }
}

def getTempPath() {
    return new File("$projectDir/../.temp").getPath()//.getAbsolutePath()
}


def buildHostModule(subdir, buildType) {
    def toolchain = getLocalToolchain()
    def buildKey = "host"
    def workingFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def outputFolder = joinPath(getOutPath(), buildKey)
    def cmakeProjectFolder = joinPath("$projectDir", subdir)
    def buildFolders = new BuildFolders(cmakeProjectFolder, workingFolder, outputFolder)

    runHostCMake(project, buildFolders, toolchain, buildType)

    def cmdLine = ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }
    return [buildKey: buildKey, outputFolder: outputFolder]
}

def buildNativeModules(BuildOptions buildOptions, Toolchain toolchain, Collection<NativeLibrary> libraries, subdir) {
    def buildKey = toolchain.getBuildKey(buildOptions)

    def workingFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def outputFolder = joinPath(getOutPath(), buildKey)
    def cmakeProjectFolder = joinPath("$projectDir", subdir)
    def buildFolders = new BuildFolders(cmakeProjectFolder, workingFolder, outputFolder)

    runAndroidCMake(project, buildFolders, toolchain, buildOptions, libraries)

    def cmdLine = !toolchain.getNinjaPath().isEmpty() ? [toolchain.getNinjaPath()] : ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }

    def jsonDescription = new File(joinPath(outputFolder, "abi.json"))
    jsonDescription.text = '{"abi":"'+buildOptions.arch+'","api":'+toolchain.getAndroidVersion()+
        ',"ndk":'+toolchain.getNdkVersionNumber()+',"stl":"'+buildOptions.stl+'"}'

    return [arch: buildOptions.arch, buildKey: buildKey]
}

task cleanPath(type: Delete) {
    delete getOutPath()
    delete getPackagePath()
    delete getTempPath()
    delete getBuildPath()
}

def executeCmd(cmd, dir) {
    def out = new StringBuilder()
    def err = new StringBuilder()
    def process = cmd.execute(null, new File(dir))
    process.consumeProcessOutput(out, err)
    process.waitFor()
    logger.info("Runnig $cmd")
    if(out.length()>0)
        logger.info(out.toString())
    if(err.length()>0)
        logger.error(err.toString())
}

// Create outAr from the contents of inArs
// All files taken/created in dir
def repackArchives(dir, inArs, outAr) {
    def arPath = getLocalToolchain().getArPath()
    if (OperatingSystem.current().isWindows()) {
        inArs.each {
            executeCmd("cmd /c ${arPath} -x ${it}", dir)
        }
        executeCmd("cmd /c for %i in (*.o) do ${arPath} -rcs ${outAr} %i", dir)
        executeCmd("cmd /c del *.o", dir)
    }  else {
        def cmd = /pushd $dir &&/
        inArs.each {
            cmd <<= /$arPath -x $it &&/
        }
        cmd <<= /$arPath -rcs $outAr *.o && rm *.o && popd/
        ['/bin/bash', '-c', cmd.toString()].execute().waitFor()
    }
}

def copyLibraryToPrefabAar(buildInfo, outFolder, library) {
    def libraryName = library.nativeLibraryName
    def prefabName = library.aarLibraryName
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = joinPath(getTempPath(), buildKey, '.cmake', libraryName)
    def buildFolder = joinPath(getPackagePath(), outFolder)
    def sharedLibBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName, 'libs',
                                  'android.'+buildKey)
    def staticLibBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName + '_static', 'libs',
                                  'android.'+buildKey)
    def staticsFolder = joinPath(getOutPath(), buildKey)
    def sharedIncludeBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName, 'include', libraryName)
    def staticIncludeBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName + '_static', 'include', libraryName)
    def headerFolder = './include/' + libraryName

    // TODO: including the dynamic library (uncommenting these next lines)
    // errors because no proper library can be found for module swappy (the shared version),
    // probably because we're using c++_static in samples?
    def buildSharedLibrary = false
    def buildStaticLibrary = true

    // 1. Copy dynamic library
    if (buildSharedLibrary) {
        copy {
            from file(cmakeFolder)
            include "*.so"
            into file(sharedLibBuildFolder)
            includeEmptyDirs = false
        }
        copy {
            from file(staticsFolder)
            include "*.json"
            into file(sharedLibBuildFolder)
        }
    }
    // 2. Copy the static libary
    if (buildStaticLibrary) {
        copy {
            from file(staticsFolder)
            include("lib" + libraryName + "_static.a", "*.json")
            rename("lib" + libraryName + "_static.a", "lib" + libraryName + ".a")
            into file(staticLibBuildFolder)
        }
    }
    // 3.1 Copy headers (shared library)
    if (buildSharedLibrary) {
        copy {
            from file(headerFolder)
            include "*.h"
            into file(sharedIncludeBuildFolder)
            includeEmptyDirs = false
        }
    }
    // 3.2 Copy headers (static library)
    if (buildStaticLibrary) {
        copy {
            from file(headerFolder)
            include "*.h"
            into file(staticIncludeBuildFolder)
            includeEmptyDirs = false
        }
    }
    // 4. Copy the manifest
    copy {
        from file("./src")
        include "AndroidManifest.xml"
        into file(buildFolder)
        includeEmptyDirs = false
    }
    // 5. Create the json files
    def jsonPrefabDescription = new File(joinPath(buildFolder, 'prefab', 'prefab.json'))
    jsonPrefabDescription.text = '{"name":"' + prefabName + '","schema_version":1,"dependencies":[],"version":"1.3.0"}'
    if (buildSharedLibrary) {
        def jsonModuleDescription = new File(joinPath(buildFolder, 'prefab', 'modules', libraryName, 'module.json'))
        jsonModuleDescription.text = '{"library_name": "lib' + libraryName + '", "export_libraries": []}'
    }
    if (buildStaticLibrary) {
        def jsonStaticModuleDescription = new File(joinPath(buildFolder, 'prefab', 'modules', libraryName + '_static', 'module.json'))
        jsonStaticModuleDescription.text = '{"library_name": "lib' + libraryName + '", "export_libraries": []}'
    }
}

def sdkCopy(buildInfo, outFolder, Collection<NativeLibrary> libraries, staticToo = false,
            useFullBuildKey = false, flattenLibDirs = false, shared = true) {
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def buildFolder = joinPath(getPackagePath(), outFolder)
    def libBuildFolder = joinPath(buildFolder, 'libs',
                                  useFullBuildKey ? buildKey : arch, 'lib')

    if (shared) {
        libraries.forEach({ nativeLibrary ->
            copy {
                from file(cmakeFolder)
                include nativeLibrary.nativeLibraryName + "*/lib*.so"
                into file(libBuildFolder)
                includeEmptyDirs = false
                if (flattenLibDirs) {
                    eachFile {
                        path = name
                    }
                }
            }
        })
    }
    if (staticToo) {
        def staticsFolder = joinPath(getOutPath(), buildKey)
        def staticLibsBuildFolder = joinPath(buildFolder, 'libs', buildKey)
        def staticLibs = []
        libraries.forEach({nativeLibrary ->
            staticLibs += "lib" + nativeLibrary.nativeLibraryName + "_static.a"
        })
        repackArchives(staticsFolder, staticLibs, 'libgamesdk.a')
        copy {
            from file(staticsFolder)
            include "libgamesdk.a"
            into file(staticLibsBuildFolder)
        }
    }
}

def copyExtras(outFolder, Collection<NativeLibrary> libraries) {
    def buildFolder = getPackagePath() + '/' + outFolder
    def headerFolder = './include'
    def aarFolder = joinPath(getOutPath(), 'outputs', 'aar')
    def includeBuildFolder = joinPath(buildFolder, 'include')
    def aarBuildFolder = joinPath(buildFolder, 'aar')

    libraries.forEach({ nativeLibrary ->
        copy {
            from file(headerFolder)
            include nativeLibrary.nativeLibraryName + "*/*.h"
            into file(includeBuildFolder)
            includeEmptyDirs = false
        }
    })
    copy {
        from file(aarFolder)
        into file(aarBuildFolder)
        includeEmptyDirs = false
    }
}

def copyDocs(outFolder) {
    copy {
        from "LICENSE", "THIRD_PARTY_NOTICES", "RELEASE_NOTES"
        into getPackagePath() + '/' + outFolder
    }
}

// Copy samples for packaging. Also rename CMakeLists.txt files so that the
// one distributed are using the packaged game sdk.
def copySamples(outFolder, Collection<NativeLibrary> libraries) {
    def buildFolder = getPackagePath() + '/' + outFolder

    // CMake utility for the Game SDK
    copy {
        from file(joinPath('samples', "gamesdk.cmake"))
        into file(joinPath(buildFolder, 'samples'))
    }

    // All sample common files
    copy {
        from file(joinPath('samples', "common"))
        into file(joinPath(buildFolder, 'samples', 'common'))
    }

    // Library specific files
    libraries.forEach({ nativeLibrary ->
        nativeLibrary.sampleAndroidProjectPaths.forEach({sampleFolder ->
            copy {
                from file(sampleFolder.sourcePath)
                into file(joinPath(buildFolder, sampleFolder.destinationPath))
                exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild", "**/.gradle",
                        "**/OWNERS", "**/.idea", '**/CMakeLists.txt'
                rename 'CMakeLists.for-samples-in-archive.txt', 'CMakeLists.txt'
                includeEmptyDirs = false
            }
        })

        nativeLibrary.sampleExtraFolderPaths.forEach({sampleFolder ->
            copy {
                from file(sampleFolder.sourcePath)
                into file(joinPath(buildFolder, sampleFolder.destinationPath))
                if (sampleFolder.includePattern != null) {
                    include sampleFolder.includePattern
                }
                includeEmptyDirs = false
            }
        })
    })
}

def unityNativeBuild(libraries, buildType="Release") {
    def threadChecks = false
    def allAbis = new ToolchainEnumerator().allAbis
    return allAbis.collect {
        buildNativeModules(
                new BuildOptions(buildType, threadChecks,  "c++_static", it),
                new SpecificToolchain(project, "21", "r19"),
                libraries,
                "src")
    }
}

def sdkNativeBuild(libraries, buildType="Release") {
    def threadChecks = false
    def allToolchains = new ToolchainEnumerator().enumerateAllToolchains(project)
    GParsPool.withPool {
        return allToolchains.collectParallel { enumeratedToolchain ->
            buildNativeModules(
                    new BuildOptions(
                            buildType,
                            threadChecks,
                            enumeratedToolchain.stl,
                            enumeratedToolchain.abi),
                    enumeratedToolchain.toolchain,
                    libraries,
                    "src")
        }
    }
}

def sdkAarNativeBuild(libraries, buildType) {
    def threadChecks = false
    def allAarToolchains = new ToolchainEnumerator().enumerateAllAarToolchains(project)
    GParsPool.withPool {
        return allAarToolchains.collectParallel { enumeratedToolchain ->
            buildNativeModules(
                    new BuildOptions(
                            buildType,
                            threadChecks,
                            enumeratedToolchain.stl,
                            enumeratedToolchain.abi),
                    enumeratedToolchain.toolchain,
                    libraries,
                    "src")
        }
    }
}

def specificNativeBuild(specificToolchainConfiguration, libraries,
                        buildType="Release") {
    def threadChecks = false
    def allAbis = new ToolchainEnumerator().allAbis
    def toolchain = new SpecificToolchain(project,
            specificToolchainConfiguration.sdk,
            specificToolchainConfiguration.ndk)
    return allAbis.collect {
        buildNativeModules(
                new BuildOptions(buildType, threadChecks, specificToolchainConfiguration.stl, it),
                toolchain,
                libraries,
                "src")
    }
}

def getLocalToolchain() {
    def kApiLevel = project.hasProperty("androidApiLevel") ?
        project.androidApiLevel : "24"
    return new LocalToolchain(project, kApiLevel)
}

def localNativeBuild(libraries, subdir = "src", buildType="Release") {
    def allAbis = new ToolchainEnumerator().allAbis
    def toolchain = getLocalToolchain();
    def threadChecks = true
    return allAbis.collect {
        def buildOptions = new BuildOptions(buildType, threadChecks, "c++_static", it)
        buildNativeModules(buildOptions, toolchain, libraries, subdir)
    }
}

def getBuildType() {
    return project.hasProperty("buildType") ?
        project.buildType : "Release"
}

def getPackageName() {
    return project.hasProperty("packageName") ?
            project.packageName : "gamesdk"
}

def shouldIncludeSamples() {
    return project.hasProperty("includeSamples") ?
        project.includeSamples : false
}

def getSpecificToolchainConfiguration() {
    if (!project.hasProperty("sdk") || !project.hasProperty("ndk") || !project.hasProperty("stl")) {
        throw new GradleException("""
Must set SDK, NDK and STL for a specific build,
e.g. ./gradlew packageSpecificZip -Plibraries=swappy -Psdk=14 -Pndk=r16 -Pstl='c++_static'"""
        )
    }
    return [sdk: project.sdk, ndk: project.ndk, stl: project.stl]
}

def getLibraries(allLibraries) {
    if (!project.hasProperty("libraries")) {
        return []
    }

    def requestedLibraryNames = project.libraries.split(',');
    return requestedLibraryNames.collect { requestedLibraryName ->
        def library = allLibraries.find {
            library -> library.nativeLibraryName == requestedLibraryName
        }
        if (library == null) {
            throw new GradleException("Library ${requestedLibraryName} does not exist.")
        }

        return library
    }
}

class BuildTask extends DefaultTask {
}

task build(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> sdkNativeBuild(libraries, bt) }
}

task buildUnity(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = getPackageName()
    ext.flattenLibs = true
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> unityNativeBuild(libraries, bt) }
}

task buildLocal(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries);
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = false
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> localNativeBuild(libraries, "src", bt) }
}

task buildSpecific(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = false
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt ->
        specificNativeBuild(getSpecificToolchainConfiguration(), libraries, bt)
    }
}

tasks.withType(BuildTask) {
    doFirst {
        // Ensure some libraries to build were set
        if (libraries.isEmpty()) {
            throw new GradleException("""
Must specify which libraries to build,
e.g. ./gradlew build -Plibraries=swappy,tuningfork""")
        }
    }
    doLast {
        // Clear the package path to ensure the task zip is not polluted
        // by previous build tasks.
        delete getPackagePath()
        nativeBuild(libraries, buildType).each {
            sdkCopy(it, packageName, libraries, withStaticLibs,
                    withFullBuildKey, flattenLibs, withSharedLibs)
        }
        copyExtras(packageName, libraries)

        copyDocs(packageName)

        if (withSamples) {
            copySamples(packageName, libraries)
        }
    }
}

// Build task for making an AAR that can be used with Prefab
task buildAar {
    doFirst {
        // Clear the package path to ensure AAR generation is not polluted
        // by previous build tasks.
        delete getPackagePath()
    }
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = getPackageName()
    ext.flattenLibs = false
    ext.libraries = getLibraries(allLibraries)
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = shouldIncludeSamples()
    ext.buildType = getBuildType()
    ext.nativeBuild = { libraries, bt -> sdkAarNativeBuild(libraries, bt) }
    doLast {
        nativeBuild(libraries, buildType).each { buildInfo ->
            libraries.forEach { library -> copyLibraryToPrefabAar(buildInfo, packageName, library) }
        }
    }
}

task localUnitTests {
    // These unit tests require a single connected device with target architecture set by the
    // project property 'arch'.
    // Set the property 'component' to 'tuningfork' or 'swappy' to run the required test suite.
    // e.g. ./gradlew localUnitTests -Parch=x86 -Pcomponent=tuningfork
    // arch defaults to 'arm64-v8a' and component to 'tuningfork' if they are not set.
    doLast {
        def pcomponent = 'tuningfork'
        if (project.hasProperty('component'))
            pcomponent = component
        def parch = 'arm64-v8a'
        if (project.hasProperty('arch'))
            parch = arch
        def buildInfo = localNativeBuild([swappyNativeLibrary, tuningForkNativeLibrary], "test/$pcomponent")
        def buildKey = buildInfo.buildKey.findAll{it.contains(parch)}[0]
        def cmakeFolder = getTempPath() + "/$buildKey/.cmake"
        def toolchain = getLocalToolchain();
        def adb = toolchain.getAdbPath();
        exec {
            workingDir cmakeFolder
            commandLine adb, "push", "${pcomponent}_test", "/data/local/tmp"
        }
        exec {
            workingDir cmakeFolder
            commandLine adb, "shell", "/data/local/tmp/${pcomponent}_test"
        }
    }
}

task localDeviceInfoUnitTests {
    doLast {
        def buildInfo = buildHostModule("test/device_info", "Release")
        exec {
            workingDir buildInfo.outputFolder
            commandLine "./device_info_test"
        }
    }
}

task format {
    doLast {
        def formattedFiles =
            fileTree(dir: 'src', include: ['**/*.cpp', '**/*.c', '**/*.h'], excludes: ["protobuf"]) +
            fileTree(dir: 'include', include: ['**/*.h'], excludes: ["third_party"]) +
            fileTree(dir: 'test/swappy', include: ['**/*.cpp', '**/*.c', '**/*.h']) +
            fileTree(dir: 'test/tuningfork', include: ['**/*.cpp', '**/*.c', '**/*.h'])

        formattedFiles.files.each { file ->
            exec {
                commandLine "/bin/bash"
                args "-c", "clang-format -i " + file
                workingDir projectDir
            }
        }
    }
}

// Zipping things up
def addZipTask(name, buildTask, archName) {
    def packPath = buildTask.packageName
    tasks.register(name, Zip) {
        dependsOn buildTask
        def buildFolder = joinPath(getPackagePath(), packPath)

        from fileTree(buildFolder)
        exclude archName
        destinationDirectory = file(buildFolder)
        archiveFileName = archName

        doLast {
            def outFolder = getBuildPath();
            mkdir outFolder;

            copy {
                from file(archiveName)
                into outFolder
            }

            if (getDistPath() != getPackagePath()) {
                copy {
                    from getPackagePath()
                    into getDistPath()
                }
            }

            def out = services.get(StyledTextOutputFactory).create("output")
            out.style(Style.Identifier).text('\n' + archName +' is in ')
            .style(Style.ProgressStatus)
                .println(destinationDirectory.get());
        }
    }

}

task prepareMavenZipContent {
    description "Build the AAR and prepare the versioned pom file for the specified library"
    dependsOn "packageAar"

    doLast {
        def buildFolder = joinPath(getPackagePath(), getPackageName())
        def mavenZipContentFolder = joinPath(buildFolder, "maven-zip");
        delete mavenZipContentFolder
        mkdir mavenZipContentFolder

        getLibraries(allLibraries).forEach { nativeLibrary ->
            def libraryName = nativeLibrary.aarLibraryName
            def aarVersion = nativeLibrary.aarVersion

            copy {
                from file(joinPath(buildFolder, "gamesdk.aar"))
                into file(joinPath(mavenZipContentFolder))
                rename "gamesdk.aar", libraryName + "-" + aarVersion + ".aar"
            }

            copy {
                from file(joinPath("src", "maven", libraryName + ".pom"))
                into file(joinPath(mavenZipContentFolder))
                rename libraryName + ".pom", libraryName + "-" + aarVersion + ".pom"
                filter(ReplaceTokens, tokens: [aarVersion: aarVersion])
            }
        }
    }
}

// Generate a zip file with the library AAR and its pom file, all versioned,
// so that it's ready to be uploaded to Maven.
task packageMavenZip(type: Zip) {
    dependsOn prepareMavenZipContent

    def buildFolder = joinPath(getPackagePath(), getPackageName())
    def mavenZipContentFolder = joinPath(buildFolder, "maven-zip")
    from fileTree(mavenZipContentFolder)
    destinationDirectory = file(buildFolder)
    def aarName = getLibraries(allLibraries).collect { it.aarLibraryName }.join('-')
    archiveFileName = aarName + "-maven-zip.zip"

    // Don't lose time compressing already compressed files
    entryCompression = ZipEntryCompression.STORED

    doLast {
        if (getDistPath() != getPackagePath()) {
            copy {
                from getPackagePath()
                into getDistPath()
            }
        }
    }
}

addZipTask("packageUnityZip", buildUnity, "builds.zip")
addZipTask("packageZip", build, "gamesdk.zip")
addZipTask("packageLocalZip", buildLocal, "gamesdk.zip")
addZipTask("packageSpecificZip", buildSpecific, "gamesdk.zip")
addZipTask("packageAar", buildAar, "gamesdk.aar")