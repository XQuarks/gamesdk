import com.google.androidgamesdk.BuildFolders
import com.google.androidgamesdk.BuildOptions
import com.google.androidgamesdk.SpecificToolchain
import com.google.androidgamesdk.LocalToolchain
import com.google.androidgamesdk.Toolchain

import java.nio.file.Paths
import org.gradle.internal.logging.text.StyledTextOutput;
import org.gradle.internal.logging.text.StyledTextOutputFactory;
import static org.gradle.internal.logging.text.StyledTextOutput.Style;
import org.gradle.internal.os.OperatingSystem;
import org.gradle.api.Project;
import static groovy.lang.Closure.IDENTITY;
import groovy.util.GroovyCollections;
import groovyx.gpars.GParsPool;
import org.apache.tools.ant.filters.ReplaceTokens;
import com.google.androidgamesdk.ExternalToolName;
import static com.google.androidgamesdk.OsSpecificTools.osFolderName;
import static com.google.androidgamesdk.CMakeWrapper.runAndroidCMake;
import static com.google.androidgamesdk.CMakeWrapper.runHostCMake;

buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.2'
        classpath "org.codehaus.gpars:gpars:1.2.0"
    }
}

defaultTasks 'cleanPath', 'archiveZip'

def protobufInstallDir() {
    return new File("$projectDir/third_party/protobuf-3.0.0/install/"
        + osFolderName(ExternalToolName.PROTOBUF)).getPath()
}

def joinPath(String first, String... more) {
    return Paths.get(first, more).toString()
}

def getEnvironment() {
    def env = [:]
    def trans = IDENTITY
    if (OperatingSystem.current().isWindows()) {
        trans = { it.toUpperCase() }
    }
    System.getenv().each{entry -> env[trans(entry.key)] = entry.value}
    return env
}

task prepare_proto_before {
    def protocBinDir = protobufInstallDir() + "/bin"
    def env = getEnvironment()
    env['PATH'] = protocBinDir + System.getProperty("path.separator") + env['PATH']
    doLast {
        // Install python-protobuf
        exec {
            workingDir "./third_party/protobuf-3.0.0/python"
            setEnvironment env
            commandLine "python", "setup.py", "install", "--user"
        }
        // Generate nano-pb requirements
        exec {
            workingDir '../external/nanopb-c/generator/proto'
            setEnvironment env
            commandLine 'make'
        }
    }
}

task prepare_proto(dependsOn: prepare_proto_before) {
    doLast {
        exec {
            commandLine "python"
            args = ["ab_info.py"]
        }
    }
}


allprojects {
    buildDir = getOutPath()
    repositories {
        google()
        jcenter()
    }
}

def getBuildPath() {
    return new File("$projectDir/build").getPath()
}

def getOutPath() {
    return new File("$projectDir/../out").getPath()
}

def getPackagePath() {
    return new File("$projectDir/../package").getPath();
}

def getDistPath() {
    def distDir = System.getenv('DIST_DIR');
    if (distDir != null) {
        return new File(distDir).getPath();
    }
    else {
        return getPackagePath();
    }
}

def getTempPath() {
    return new File("$projectDir/../.temp").getPath()//.getAbsolutePath()
}


def buildHostModule(subdir, buildType) {
    def toolchain = getLocalToolchain();
    def buildKey = "host"
    def workingFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def outputFolder = joinPath(getOutPath(), buildKey)
    def cmakeProjectFolder = joinPath("$projectDir", subdir)
    def buildFolders = new BuildFolders(cmakeProjectFolder, workingFolder, outputFolder)

    runHostCMake(project, buildFolders, toolchain, buildType)

    def cmdLine = ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }
    return [buildKey: buildKey, outputFolder: outputFolder]
}

def buildNativeModules(BuildOptions buildOptions, Toolchain toolchain, buildtf, subdir) {
    def buildKey = toolchain.getBuildKey(buildOptions)

    def workingFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def outputFolder = joinPath(getOutPath(), buildKey)
    def cmakeProjectFolder = joinPath("$projectDir", subdir)
    def buildFolders = new BuildFolders(cmakeProjectFolder, workingFolder, outputFolder)

    runAndroidCMake(project, buildFolders, toolchain, buildOptions, buildtf)

    def cmdLine = !toolchain.getNinjaPath().isEmpty() ? [toolchain.getNinjaPath()] : ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }

    def jsonDescription = new File(joinPath(outputFolder, "abi.json"))
    jsonDescription.text = '{"abi":"'+buildOptions.arch+'","api":'+toolchain.getAndroidVersion()+
        ',"ndk":'+toolchain.getNdkVersionNumber()+',"stl":"'+buildOptions.stl+'"}'

    return [arch: buildOptions.arch, buildKey: buildKey]
}

task cleanPath(type: Delete) {
    delete getOutPath()
    delete getPackagePath()
    delete getTempPath()
    delete getBuildPath()
}

def executeCmd(cmd, dir) {
    def out = new StringBuilder()
    def err = new StringBuilder()
    def process = cmd.execute(null, new File(dir))
    process.consumeProcessOutput(out, err)
    process.waitFor()
    logger.info("Runnig $cmd")
    if(out.length()>0)
        logger.info(out.toString())
    if(err.length()>0)
        logger.error(err.toString())
}

// Create outAr from the contents of inArs
// All files taken/created in dir
def repackArchives(dir, inArs, outAr) {
    def arPath = getLocalToolchain().getArPath()
    if (OperatingSystem.current().isWindows()) {
        inArs.each {
            executeCmd("cmd /c ${arPath} -x ${it}", dir)
        }
        executeCmd("cmd /c for %i in (*.o) do ${arPath} -rcs ${outAr} %i", dir)
        executeCmd("cmd /c del *.o", dir)
    }  else {
        def cmd = /pushd $dir &&/
        inArs.each {
            cmd <<= /$arPath -x $it &&/
        }
        cmd <<= /$arPath -rcs $outAr *.o && rm *.o && popd/
        ['/bin/bash', '-c', cmd.toString()].execute().waitFor()
    }
}

def copyLibraryToPrefabAar(buildInfo, outFolder, libraryName, prefabName) {
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = joinPath(getTempPath(), buildKey, '.cmake', libraryName)
    def buildFolder = joinPath(getPackagePath(), outFolder)
    def sharedLibBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName, 'libs',
                                  'android.'+buildKey)
    def staticLibBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName + '_static', 'libs',
                                  'android.'+buildKey)
    def staticsFolder = joinPath(getOutPath(), buildKey)
    def sharedIncludeBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName, 'include', libraryName)
    def staticIncludeBuildFolder = joinPath(buildFolder, 'prefab','modules', libraryName + '_static', 'include', libraryName)
    def headerFolder = './include/' + libraryName

    // TODO: including the dynamic library (uncommenting these next lines)
    // errors because no proper library can be found for module swappy (the shared version),
    // probably because we're using c++_static in samples?
    def buildSharedLibrary = false
    def buildStaticLibrary = true

    // 1. Copy dynamic library
    if (buildSharedLibrary) {
        copy {
            from file(cmakeFolder)
            include "*.so"
            into file(sharedLibBuildFolder)
            includeEmptyDirs = false
        }
        copy {
            from file(staticsFolder)
            include "*.json"
            into file(sharedLibBuildFolder)
        }
    }
    // 2. Copy the static libary
    if (buildStaticLibrary) {
        copy {
            from file(staticsFolder)
            include "lib" + libraryName + "_static.a","*.json"
            rename("lib" + libraryName + "_static.a", "lib" + libraryName + ".a")
            into file(staticLibBuildFolder)
        }
    }
    // 3.1 Copy headers (shared library)
    if (buildSharedLibrary) {
        copy {
            from file(headerFolder)
            include "*.h"
            into file(sharedIncludeBuildFolder)
            includeEmptyDirs = false
        }
    }
    // 3.2 Copy headers (static library)
    if (buildStaticLibrary) {
        copy {
            from file(headerFolder)
            include "*.h"
            into file(staticIncludeBuildFolder)
            includeEmptyDirs = false
        }
    }
    // 4. Copy the manifest
    copy {
        from file("./src")
        include "AndroidManifest.xml"
        into file(buildFolder)
        includeEmptyDirs = false
    }
    // 5. Create the json files
    def jsonPrefabDescription = new File(joinPath(buildFolder, 'prefab', 'prefab.json'))
    jsonPrefabDescription.text = '{"name":"' + prefabName + '","schema_version":1,"dependencies":[],"version":"1.3.0"}'
    if (buildSharedLibrary) {
        def jsonModuleDescription = new File(joinPath(buildFolder, 'prefab', 'modules', libraryName, 'module.json'))
        jsonModuleDescription.text = '{"library_name": "lib' + libraryName + '", "export_libraries": []}'
    }
    if (buildStaticLibrary) {
        def jsonStaticModuleDescription = new File(joinPath(buildFolder, 'prefab', 'modules', libraryName + '_static', 'module.json'))
        jsonStaticModuleDescription.text = '{"library_name": "lib' + libraryName + '", "export_libraries": []}'
    }
}

def sdkCopy(buildInfo, outFolder, all = true, staticToo = false,
            useFullBuildKey = false, flattenLibDirs = false, shared = true) {
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = joinPath(getTempPath(), buildKey, '.cmake')
    def buildFolder = joinPath(getPackagePath(), outFolder)
    def libBuildFolder = joinPath(buildFolder, 'libs',
                                  useFullBuildKey ? buildKey : arch, 'lib')

    if (shared) {
        copy {
            from file(cmakeFolder)
            include all ? "*/lib*.so" : "swappy*/lib*.so"
            into file(libBuildFolder)
            includeEmptyDirs = false
            if (flattenLibDirs) {
                eachFile {
                    path = name
                }
            }
        }
    }
    if (staticToo) {
        def staticsFolder = joinPath(getOutPath(), buildKey)
        def staticLibsBuildFolder = joinPath(buildFolder, 'libs', buildKey)
        def staticLibs = ['libswappy_static.a']
        if (all)
            staticLibs += 'libtuningfork_static.a'
        repackArchives(staticsFolder, staticLibs, 'libgamesdk.a')
        copy {
            from file(staticsFolder)
            include "libgamesdk.a"
            into file(staticLibsBuildFolder)
        }
    }
}

def copyExtras(outFolder, all = true) {
    def buildFolder = getPackagePath() + '/' + outFolder
    def headerFolder = './include'
    def aarFolder = joinPath(getOutPath(), 'outputs', 'aar')
    def includeBuildFolder = joinPath(buildFolder, 'include')
    def aarBuildFolder = joinPath(buildFolder, 'aar')

    copy {
        from file(headerFolder)
        include all ? "*/*.h" : "swappy*/*.h"
        into file(includeBuildFolder)
        includeEmptyDirs = false
    }
    copy {
        from file(aarFolder)
        into file(aarBuildFolder)
        includeEmptyDirs = false
    }
}

def copyDocs(outFolder) {
    copy {
        from "LICENSE", "THIRD_PARTY_NOTICES", "RELEASE_NOTES"
        into getPackagePath() + '/' + outFolder
    }
}

// Copy samples for packaging. Also rename CMakeLists.txt files so that the
// one distributed are using the packaged game sdk.
def copySamples(outFolder, includeTuningForkSamples = true) {
    def buildFolder = getPackagePath() + '/' + outFolder

    // CMake utility for the Game SDK
    copy {
        from file(joinPath('samples', "gamesdk.cmake"))
        into file(joinPath(buildFolder, 'samples'))
    }

    // All sample common files
    copy {
        from file(joinPath('samples', "common"))
        into file(joinPath(buildFolder, 'samples', 'common'))
    }

    // Bouncyball
    copy {
        from file(joinPath('samples', "bouncyball"))
        into file(joinPath(buildFolder, 'samples', "bouncyball"))
        exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild", "**/.gradle",
            "**/OWNERS", "**/.idea", '**/CMakeLists.txt'
        rename 'CMakeLists.for-samples-in-archive.txt', 'CMakeLists.txt'
        includeEmptyDirs = false
    }

    // Cube
    copy {
        from file(joinPath('samples', "cube"))
        into file(joinPath(buildFolder, 'samples', "cube"))
        exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild",
            "**/.gradle", "**/OWNERS", "**/.idea"
        includeEmptyDirs = false
    }
    copy {
        from file(joinPath('third_party', "cube"))
        into file(joinPath(buildFolder, 'third_party', "cube"))
        rename 'CMakeLists.for-samples-in-archive.txt', 'CMakeLists.txt'
        exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild", "**/.gradle",
            "**/OWNERS", "**/.idea"
        includeEmptyDirs = false
    }

    if (includeTuningForkSamples) {
        // All Tuning Fork sample common files
        copy {
            from file(joinPath('samples', 'tuningfork', "common"))
            into file(joinPath(buildFolder, 'samples', 'tuningfork', 'common'))
        }

        copy {
                from file(joinPath('samples', "tuningfork", "experimentsdemo"))
                into file(joinPath(buildFolder, 'samples', "tuningfork", "experimentsdemo"))
                exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild", "**/.gradle",
            "**/OWNERS", "**/.idea", '**/CMakeLists.txt'
                rename 'CMakeLists.for-samples-in-archive.txt', 'CMakeLists.txt'
                includeEmptyDirs = false
        }
        copy {
                from file(joinPath('samples', "tuningfork", "insightsdemo"))
                into file(joinPath(buildFolder, 'samples', "tuningfork", "insightsdemo"))
                exclude '**/build', '**/out', "local.properties", "**/.externalNativeBuild", "**/.gradle",
            "**/OWNERS", "**/.idea", '**/CMakeLists.txt'
                rename 'CMakeLists.for-samples-in-archive.txt', 'CMakeLists.txt'
                includeEmptyDirs = false
        }
        copy {
                from file(joinPath('src', 'protobuf'))
                into file(joinPath(buildFolder, 'src', 'protobuf'))
                includeEmptyDirs = false
        }
        copy {
                from file(joinPath('third_party', 'protobuf-3.0.0'))
                into file(joinPath(buildFolder, 'third_party', 'protobuf-3.0.0'))
                includeEmptyDirs = false
        }
        copy {
                from file(joinPath('..', 'external', 'nanopb-c'))
                into file(joinPath(buildFolder, 'external', 'nanopb-c'))
                includeEmptyDirs = false
        }
        copy {
                from file(joinPath('src', 'tuningfork', 'tools', 'validation'))
                into file(joinPath(buildFolder, 'src', 'tuningfork', 'tools', 'validation'))
                exclude '**/build'
                includeEmptyDirs = false
        }
        copy {
                from file(joinPath('src', 'tuningfork', 'proto'))
                into file(joinPath(buildFolder, 'src', 'tuningfork', 'proto'))
                include 'tuningfork.proto'
                includeEmptyDirs = false
        }
    }
}

def abis32Bits() { return ["armeabi-v7a", "x86"] }
def abis64Bits() { return ["arm64-v8a", "x86_64"] }
def defaultAbis() { return abis32Bits() + abis64Bits() }
def allSTLs() { return ["c++_static", "c++_shared", "gnustl_static", "gnustl_shared"] }
def post17STLs() { return ["c++_static", "c++_shared"] }
def versionMapping() { return [ [["r14"], [14,15,16,17,18,19,20,21,22,23,24]],
                               [["r15"], [14,15,16,17,18,19,21,22,23,24,26]],
                               [["r16"], [14,15,16,17,18,19,21,22,23,24,26,27]],
                               [["r17"], [14,15,16,17,18,19,21,22,23,24,26,27,28]]] }
def versionMappingPost17() { return [ [["r18"], [16,17,18,19,21,22,23,24,26,27,28]],
                               [["r19"], [16,17,18,19,21,22,23,24,26,27,28]],
                               [["r20"], [16,17,18,19,21,22,23,24,26,27,28]],
                               [["r21"], [16,17,18,19,21,22,23,24,26,27,28,29]]] }

def unityNativeBuild(withTuningFork=false, buildType="Release") {
    def threadChecks = false
    return defaultAbis().collect {
        buildNativeModules(
                new BuildOptions(buildType, threadChecks,  "c++_static", it),
                new SpecificToolchain(project, "21", "r19"),
                withTuningFork,
                "src")
    }
}

def sdkNativeBuild(withTuningFork = true, buildType="Release") {
    def threadChecks = false

    def versions = versionMapping().collectMany { GroovyCollections.combinations(it) }
    def versionsPost17 = versionMappingPost17().collectMany { GroovyCollections.combinations(it) }
    def allCombos = GroovyCollections.combinations(defaultAbis(), versions, allSTLs()) +
        GroovyCollections.combinations(defaultAbis(), versionsPost17, post17STLs());
    GParsPool.withPool {
        return allCombos.collectParallel { x ->
            def arch = x[0];
            def stl = x[2];
            buildNativeModules(
                    new BuildOptions(buildType, threadChecks, stl, arch),
                    new SpecificToolchain(
                            project,
                            /*androidVersion=*/ x[1][1].toString(),
                            /*ndkVersion=*/ x[1][0]
                    ),
                    withTuningFork,
                    "src")
        }
    }
}

// For the AAR, only build the dynamic libraries against shared STL.
def aarSTLs() { return ["c++_shared", "gnustl_shared"] }
def aarPost17STLs() { return ["c++_shared"] }

// In the AAR, library search is handled by Prefab, that looks for API 21 for 64 bits architectures
// even if a lower API level is requested. We need to build a different set of libraries for 32 and
// 64 bits as a consequence.
def aarVersionMapping32Bits() { return versionMapping() }
def aarVersionMapping32BitsPost17() { return versionMappingPost17() }
def aarVersionMapping64Bits() { return [ [["r14"], [21,22,23,24]],
                               [["r15"], [21,22,23,24,26]],
                               [["r16"], [21,22,23,24,26,27]],
                               [["r17"], [21,22,23,24,26,27,28]]] }
def aarVersionMapping64BitsPost17() { return [ [["r18"], [21,22,23,24,26,27,28]],
                               [["r19"], [21,22,23,24,26,27,28]],
                               [["r20"], [21,22,23,24,26,27,28]],
                               [["r21"], [21,22,23,24,26,27,28,29]]] }

def sdkAarNativeBuild(withTuningFork = true, buildType="Release") {
    def threadChecks = false

    def versions32Bits = aarVersionMapping32Bits().collectMany { GroovyCollections.combinations(it) }
    def versions32BitsPost17 = aarVersionMapping32BitsPost17().collectMany { GroovyCollections.combinations(it) }
    def versions64Bits = aarVersionMapping64Bits().collectMany { GroovyCollections.combinations(it) }
    def versions64BitsPost17 = aarVersionMapping64BitsPost17().collectMany { GroovyCollections.combinations(it) }
    def allCombos =
        GroovyCollections.combinations(abis32Bits(), versions32Bits, aarSTLs()) +
        GroovyCollections.combinations(abis32Bits(), versions32BitsPost17, aarPost17STLs()) +
        GroovyCollections.combinations(abis64Bits(), versions64Bits, aarSTLs()) +
        GroovyCollections.combinations(abis64Bits(), versions64BitsPost17, aarPost17STLs());
    GParsPool.withPool {
        return allCombos.collectParallel { x ->
            def arch = x[0]
            def stl = x[2]
            buildNativeModules(
                    new BuildOptions(buildType, threadChecks, stl, arch),
                    new SpecificToolchain(
                            project,
                            /*androidVersion=*/ x[1][1].toString(),
                            /*ndkVersion=*/ x[1][0]
                    ),
                    withTuningFork,
                    "src")
        }
    }
}

def specificNativeBuild(sdkVersion, ndkVersion, stlVersion, withTuningFork = false,
                        buildType="Release") {
    def threadChecks = false

    def toolchain = new SpecificToolchain(project, sdkVersion, ndkVersion)
    return defaultAbis().collect {
        buildNativeModules(
                new BuildOptions(buildType, threadChecks, stlVersion, it),
                toolchain,
                withTuningFork,
                "src")
    }
}

def getLocalToolchain() {
    def kApiLevel = project.hasProperty("GAMESDK_ANDROID_API_LEVEL") ?
        project.GAMESDK_ANDROID_API_LEVEL : "24"
    return new LocalToolchain(project, kApiLevel)
}

def localNativeBuild(withTuningFork = false, subdir = "src", buildType="Release") {
    def toolchain = getLocalToolchain();
    def threadChecks = true
    return defaultAbis().collect {
        def buildOptions = new BuildOptions(buildType, threadChecks, "c++_static", it)
        buildNativeModules(buildOptions, toolchain, withTuningFork, subdir)
    }
}

def defaultBuildType() {
    return project.hasProperty("GAMESDK_BUILD_TYPE") ?
        project.GAMESDK_BUILD_TYPE : "Release"
}

class BuildTask extends DefaultTask {
}

// Just build swappy shared libraries
task swappyUnityBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = 'swappyUnity'
    ext.flattenLibs = true
    ext.withTuningFork = false
    ext.withSharedLibs = false
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = false
    ext.buildType = "Release";
    ext.nativeBuild = { tf,bt -> unityNativeBuild(tf,bt) }
}
task swappyUnityDebugBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = 'swappyUnity'
    ext.flattenLibs = true
    ext.withTuningFork = false
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = false
    ext.buildType = "Debug";
    ext.nativeBuild = { tf,bt -> unityNativeBuild(tf,bt) }
}

// Full build including tuning fork for unity, shared libraries only
task unityBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'unity'
    ext.flattenLibs = true
    ext.withTuningFork = true
    ext.withSharedLibs = false
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = false
    ext.buildType = "Release";
    ext.nativeBuild = { tf,bt -> unityNativeBuild(tf,bt) }
}

// Build everything
task fullSdkBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'fullsdk'
    ext.flattenLibs = false
    ext.withTuningFork = true
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = true
    ext.buildType = "Release"
    ext.nativeBuild = { tf,bt -> sdkNativeBuild(tf,bt) }
}

// Build everything without TF
task releaseSdkBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'gamesdk'
    ext.flattenLibs = false
    ext.withTuningFork = false
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = true
    ext.buildType = "Release";
    ext.nativeBuild = { tf,bt -> sdkNativeBuild(tf,bt) }
}

task gamingFramePacingAarSdkBuild() {
    doFirst {
        // Clear the package path to ensure AAR generation is not polluted
        // by previous build tasks.
        delete getPackagePath()
    }
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'gamesdk'
    ext.flattenLibs = false
    ext.withTuningFork = false
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = true
    ext.buildType = "Release";
    ext.nativeBuild = { tf,bt -> sdkAarNativeBuild(tf,bt) }
    doLast {
        nativeBuild(withTuningFork, buildType).each {
            copyLibraryToPrefabAar(it, packageName, 'swappy', 'gaming-frame-pacing');
        }
    }
}

// Same as gamingFramePacingAarSdkBuild but with fullsdk package name
task gamingFramePacingAarFullSdkBuild() {
    doFirst {
        // Clear the package path to ensure AAR generation is not polluted
        // by previous build tasks.
        delete getPackagePath()
    }
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'fullsdk'
    ext.flattenLibs = false
    ext.withTuningFork = false
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = true
    ext.buildType = "Release";
    ext.nativeBuild = { tf,bt -> sdkAarNativeBuild(tf,bt) }
    doLast {
        nativeBuild(withTuningFork, buildType).each {
            copyLibraryToPrefabAar(it, packageName, 'swappy', 'gaming-frame-pacing');
        }
    }
}

task gamingPerformanceTunerAarFullSdkBuild() {
    doFirst {
        // Clear the package path to ensure AAR generation is not polluted
        // by previous build tasks.
        delete getPackagePath()
    }
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'fullsdk'
    ext.flattenLibs = false
    ext.withTuningFork = true
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = true
    ext.buildType = "Release";
    ext.nativeBuild = { tf,bt -> sdkAarNativeBuild(tf,bt) }
    doLast {
        nativeBuild(withTuningFork, buildType).each {
            copyLibraryToPrefabAar(it, packageName, 'tuningfork', 'gaming-performance-tuner');
        }
    }
}

// Build everything in debug without TF
task debugSdkBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'gamesdk_debug'
    ext.flattenLibs = false
    ext.withTuningFork = false
    ext.withSharedLibs = true
    ext.withStaticLibs = true
    ext.withFullBuildKey = true
    ext.withSamples = true
    ext.buildType = "Debug";
    ext.nativeBuild = { tf,bt -> sdkNativeBuild(tf,bt) }
}

// Build using local SDK, no tuning fork
task localBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = 'local'
    ext.flattenLibs = false
    ext.withTuningFork = false;
    ext.withSharedLibs = true
    ext.withStaticLibs = true;
    ext.withFullBuildKey = false;
    ext.withSamples = false;
    ext.buildType = defaultBuildType();
    ext.nativeBuild = { tf,bt -> localNativeBuild(tf, "src", bt) }
}

// Build using local SDK, with tuning fork
task localTfBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease', prepare_proto
    ext.packageName = 'localtf'
    ext.flattenLibs = false
    ext.withTuningFork = true;
    ext.withSharedLibs = true
    ext.withStaticLibs = true;
    ext.withFullBuildKey = false;
    ext.withSamples = false;
    ext.buildType = defaultBuildType();
    ext.nativeBuild = { tf,bt -> localNativeBuild(tf, "src", bt) }
}

task specificBuild(type: BuildTask) {
    dependsOn ':extras:assembleRelease'
    ext.packageName = "specific"
    ext.flattenLibs = false
    ext.withTuningFork = false;
    ext.withSharedLibs = true
    ext.withStaticLibs = true;
    ext.withFullBuildKey = false;
    ext.withSamples = true;
    ext.buildType = defaultBuildType();
    ext.nativeBuild = { tf,bt ->
        def sdk = System.getenv("SDK")
        def ndk = System.getenv("NDK")
        def stl = System.getenv("STL")
        if (sdk==null || ndk==null || stl==null) {
            throw new GradleException("""
Must set SDK, NDK and STL for a specific build,
e.g. SDK=14 NDK=r16 STL='c++_static' ./gradlew specificZip"""
            )
        }
        specificNativeBuild(sdk, ndk, stl, tf, bt)
    }
}

tasks.withType(BuildTask) {
    doLast {
        // Clear the package path to ensure the task zip is not polluted
        // by previous build tasks.
        delete getPackagePath()
        nativeBuild(withTuningFork, buildType).each {
            sdkCopy(it, packageName, withTuningFork, withStaticLibs,
                    withFullBuildKey, flattenLibs, withSharedLibs)
        }
        copyExtras(packageName, withTuningFork)

        copyDocs(packageName)

        if (withSamples) {
            copySamples(packageName, withTuningFork)
        }
    }
}

task localUnitTests {
    // These unit tests require a single connected device with target architecture set by the
    // project property 'arch'.
    // Set the property 'component' to 'tuningfork' or 'swappy' to run the required test suite.
    // e.g. ./gradlew localUnitTests -Parch=x86 -Pcomponent=tuningfork
    // arch defaults to 'arm64-v8a' and component to 'tuningfork' if they are not set.
    doLast {
        def pcomponent = 'tuningfork'
        if (project.hasProperty('component'))
            pcomponent = component
        def parch = 'arm64-v8a'
        if (project.hasProperty('arch'))
            parch = arch
        def buildInfo = localNativeBuild(true, "test/$pcomponent")
        def buildKey = buildInfo.buildKey.findAll{it.contains(parch)}[0]
        def cmakeFolder = getTempPath() + "/$buildKey/.cmake"
        def toolchain = getLocalToolchain();
        def adb = toolchain.getAdbPath();
        exec {
            workingDir cmakeFolder
            commandLine adb, "push", "${pcomponent}_test", "/data/local/tmp"
        }
        exec {
            workingDir cmakeFolder
            commandLine adb, "shell", "/data/local/tmp/${pcomponent}_test"
        }
    }
}

task localDeviceInfoUnitTests {
    doLast {
        def buildInfo = buildHostModule("test/device_info", "Release")
        exec {
            workingDir buildInfo.outputFolder
            commandLine "./device_info_test"
        }
    }
}

task format {
    doLast {
        def formattedFiles =
            fileTree(dir: 'src', include: ['**/*.cpp', '**/*.c', '**/*.h'], excludes: ["protobuf"]) +
            fileTree(dir: 'include', include: ['**/*.h'], excludes: ["third_party"]) +
	    fileTree(dir: 'test/swappy', include: ['**/*.cpp', '**/*.c', '**/*.h']) +
	    fileTree(dir: 'test/tuningfork', include: ['**/*.cpp', '**/*.c', '**/*.h'])

        formattedFiles.files.each { file ->
            exec {
                commandLine "/bin/bash"
                args "-c", "clang-format -i " + file
                workingDir projectDir
            }
        }
    }
}

// Zipping things up
def addZipTask(name, buildTask, zipName) {
    def packPath = buildTask.packageName
    tasks.register(name, Zip) {
        dependsOn buildTask
        def buildFolder = joinPath(getPackagePath(), packPath)
        def archName = zipName + (zipName.contains(".") ? "" : ".zip")

        from fileTree(buildFolder)
        exclude archName
        destinationDirectory = file(buildFolder)
        archiveFileName = archName

        doLast {
            def outFolder = getBuildPath();\
            mkdir outFolder;

            copy {
                from file(archiveName)
                into outFolder
            }

            if (getDistPath() != getPackagePath()) {
                copy {
                    from getPackagePath()
                    into getDistPath()
                }
            }

            def out = services.get(StyledTextOutputFactory).create("output")
            out.style(Style.Identifier).text('\n' + archName +' is in ')
            .style(Style.ProgressStatus)
                .println(destinationDirectory.get());
        }
    }

}

// Generate a zip file with the library AAR and its pom file, all versioned,
// so that it's ready to be uploaded to Maven.
def addAarMavenZipTask(name, aarBuildTask, libraryName, aarVersion) {
    def packPath = "fullsdk"
    def buildFolder = joinPath(getPackagePath(), packPath)
    def mavenZipContentFolder = joinPath(buildFolder, libraryName + "-maven-zip");

    // After building the AAR, prepare the versioned pom file and AAR file.
    tasks.register("prepareMavenZipContentFor" + name) {
        dependsOn aarBuildTask

        doLast {
            delete mavenZipContentFolder
            mkdir mavenZipContentFolder

            copy {
                from file(joinPath(buildFolder, libraryName + ".aar"))
                into file(joinPath(mavenZipContentFolder))
                rename libraryName + ".aar", libraryName + "-" + aarVersion + ".aar"
            }

            copy {
                from file(joinPath("src", "maven", libraryName + ".pom"))
                into file(joinPath(mavenZipContentFolder))
                rename libraryName + ".pom", libraryName + "-" + aarVersion + ".pom"
                filter(ReplaceTokens, tokens: [aarVersion: aarVersion])
            }
        }
    }

    // Create a zip for upload to Maven.
    tasks.register(name, Zip) {
        dependsOn "prepareMavenZipContentFor" + name

        from fileTree(mavenZipContentFolder)
        destinationDirectory = file(buildFolder)
        archiveFileName = libraryName + "-maven-zip.zip"

        // Don't lost time compressing already compressed files
        entryCompression = ZipEntryCompression.STORED

        doLast {
            if (getDistPath() != getPackagePath()) {
                copy {
                    from getPackagePath()
                    into getDistPath()
                }
            }
        }
    }
}

addZipTask("swappyUnityZip", swappyUnityBuild, "builds")
addZipTask("swappyUnityDebugZip", swappyUnityDebugBuild, "builds")
addZipTask("unityZip", unityBuild, "builds")
addZipTask("archiveZip", localBuild, "gamesdk")
addZipTask("archiveTfZip", localTfBuild, "gamesdk")
addZipTask("fullSdkZip", fullSdkBuild, "gamesdk")
addZipTask("specificZip", specificBuild, "gamesdk")
addZipTask("gamesdkZip", releaseSdkBuild, "gamesdk")
addZipTask("gamesdkDebugZip", debugSdkBuild, "gamesdk_debug")
addZipTask("gamingFramePacingAar", gamingFramePacingAarSdkBuild, "gaming-frame-pacing.aar")
addZipTask("fullSdkGamingFramePacingAar", gamingFramePacingAarFullSdkBuild, "gaming-frame-pacing.aar")
addZipTask("fullSdkGamingPerformanceTunerAar", gamingPerformanceTunerAarFullSdkBuild, "gaming-performance-tuner.aar")
addAarMavenZipTask("fullSdkGamingFramePacingAarMavenZip", "fullSdkGamingFramePacingAar",
    "gaming-frame-pacing", "1.5.0-alpha01")
addAarMavenZipTask("fullSdkGamingPerformanceTunerAarMavenZip", "fullSdkGamingPerformanceTunerAar",
    "gaming-performance-tuner", "1.0.0-alpha01")
