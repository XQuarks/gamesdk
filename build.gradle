
import java.nio.file.Paths
import org.gradle.internal.logging.text.StyledTextOutput;
import org.gradle.internal.logging.text.StyledTextOutputFactory;
import static org.gradle.internal.logging.text.StyledTextOutput.Style;
import org.gradle.internal.os.OperatingSystem;
import org.gradle.api.Project;

defaultTasks 'clean', 'archiveZip'

task get_protoc_version(type: Exec) {
    commandLine "protoc"
    args = ["--version"]
    standardOutput = new ByteArrayOutputStream()
    ext.output = {
        return standardOutput.toString().trim()
    }
}

task check_protoc_version(dependsOn: get_protoc_version) {
    doLast {
        def version_needed = "3.0.0"
        def is_protoc_version_correct = tasks.get_protoc_version.output().endsWith(version_needed)
        def version_error_msg = "Make sure you have protoc installed and its version is exactly " + version_needed
        assert is_protoc_version_correct : version_error_msg
    }
}

task make_proto(type: Exec) {
    workingDir getExternalPath() + '/nanopb-c/generator/proto'
    commandLine 'make'
}

buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
    }
}

allprojects {
    buildDir = getOutPath()
    repositories {
        google()
        jcenter()
    }
}

abstract class Toolchain {
    abstract String getAndroidNDKPath();
    abstract String getCMakePath();
    abstract String getNinjaPath();
    abstract String getAndroidVersion();
    abstract String getBuildKey(String arch, String stl);
}
class SpecificToolchain extends Toolchain {
    private String androidVersion_;
    private String ndkVersion_;
    SpecificToolchain(String androidVersion, String ndkVersion) {
        androidVersion_ = androidVersion;
        ndkVersion_ = ndkVersion;
    }
    public String getAndroidNDKPath() {
        return new File("../prebuilts/ndk/" + ndkVersion_).getCanonicalPath()
    }
    public String getCMakePath() {
        return new File("../prebuilts/cmake/linux-x86/bin/cmake").getCanonicalPath()
    }
    public String getNinjaPath() {
        return new File("../prebuilts/cmake/linux-x86/bin/ninja").getCanonicalPath()
    }
    public String getAndroidVersion() { return androidVersion_; }
    public String getBuildKey(String arch, String stl) {
        return arch + '_' + ndkVersion_ + '_' + stl
    }
}
class LocalToolchain extends Toolchain {
    Project project_;
    String sdkPath_;
    String ndkPath_;
    String cmakePath_;
    String ninjaPath_;
    String androidVersion_;
    LocalToolchain(Project project, String androidVersion) {
        project_ = project
        androidVersion_ = androidVersion
        sdkPath_ = System.getenv("ANDROID_HOME")
        if(sdkPath_ == null)
            throw new GradleException('Must set ANDROID_HOME')
        ndkPath_ = System.getenv("ANDROID_NDK")
        if(ndkPath_ == null) {
            ndkPath_ = Paths.get(sdkPath_,'ndk-bundle').toString()
            if (!project_.file(ndkPath_).exists())
                throw new GradleException('No NDK found in SDK: must set ANDROID_NDK')
        }
        cmakePath_ = findCMakeTool("CMAKE", "cmake")
        ninjaPath_ = findCMakeTool("NINJA", "ninja")
    }
    String getAndroidNDKPath() {
        return ndkPath_;
    }
    String getCMakePath() {
        return cmakePath_;
    }
    String getNinjaPath() {
        return ninjaPath_;
    }
    String getAndroidVersion() {
        return androidVersion_;
    }
    String getBuildKey(String arch, String stl) {
        return arch + '_local_' + stl
    }
    String findCMakeTool(String envVar, String name) {
        def tool = System.getenv(envVar);
        if (tool) {
            return tool;
        }
        def osname = OperatingSystem.current().isWindows() ? name + '.exe' : name
        def tools = project_.fileTree( dir: Paths.get(sdkPath_, 'cmake').toString(), include: ['**/bin/'+osname] )
        if (tools==null || tools.size() == 0) {
            throw new GradleException('No ' + osname + ' found in ' + sdkPath_ + '/cmake')
        }
        return tools.getFiles().last().toString();
    }
}

def getOutPath() {
    return new File("../out").getCanonicalPath()
}

def getPackagePath() {
    return new File("../package").getCanonicalPath()
}

def getTempPath() {
    return new File("../.temp").getCanonicalPath()
}

def getExternalPath() {
    def f =  new File("../external/");
    if ( !f.exists() )
        f = new File("../../../external/");
    return f.getCanonicalPath()
}
def useNinja() {
    return true;
}
def cmake(projectFolder, workingFolder, outputFolder, arch, toolchain, stl,
          threadChecks) {
    def ndkPath = toolchain.getAndroidNDKPath()
    def toolchainFilePath = ndkPath + "/build/cmake/android.toolchain.cmake"
    def externalPath = getExternalPath();
    def androidVersion = toolchain.getAndroidVersion()
    def ninjaPath = toolchain.getNinjaPath()
    mkdir workingFolder
    mkdir outputFolder

    def threadFlags = ""
    if (threadChecks) {
        threadFlags = "-DGAMESDK_THREAD_CHECKS=1"
    } else {
        threadFlags = "-DGAMESDK_THREAD_CHECKS=0"
    }

    def cmdLine = [toolchain.getCMakePath(),
                   "$projectFolder",
                   "-DCMAKE_BUILD_TYPE=Release",
                   "-DANDROID_PLATFORM=android-$androidVersion",
                   "-DANDROID_NDK=$ndkPath",
                   "-DANDROID_STL=$stl",
                   "-DANDROID_ABI=$arch",
                   "-DCMAKE_CXX_FLAGS=",
                   "-DCMAKE_TOOLCHAIN_FILE=$toolchainFilePath",
                   "-DCMAKE_ARCHIVE_OUTPUT_DIRECTORY=$outputFolder",
                   "-DEXTERNAL_ROOT=$externalPath",
                   threadFlags]
    if (useNinja()) {
        cmdLine += ["-DCMAKE_MAKE_PROGRAM=" + "$ninjaPath",
                    "-GNinja"]
    }
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }
}

def buildNativeModules(arch, toolchain, stl, threadChecks) {
    def buildKey = toolchain.getBuildKey(arch, stl)
    def workingFolder = getTempPath() + '/' + buildKey + '/.cmake'
    def outputFolder = getOutPath() + '/' + buildKey
    def cmakeProjectLocation = "$projectDir/src/"

    cmake(cmakeProjectLocation, workingFolder, outputFolder, arch, toolchain, stl, threadChecks)
    def cmdLine = useNinja() ? [toolchain.getNinjaPath()] : ["make", "-j"]
    exec {
        workingDir workingFolder
        commandLine cmdLine
    }
    return [arch: arch, buildKey: buildKey]
}
def buildNativeModules(arch, androidVersion, ndkVersion, stl, threadChecks) {
    return buildNativeModules(arch,
                              new SpecificToolchain(androidVersion, ndkVersion),
                              stl, threadChecks)
}
task clean(type: Delete) {
    doLast {
        delete getOutPath(), getPackagePath(), getTempPath()
    }
}

// Create outAr from the contents of inArs
// All files taken/created in dir
def repackArchives(dir, inArs, outAr) {
    def cmd = /pushd $dir &&/
    inArs.each {
        cmd <<= /ar -x $it &&/
    }
    cmd <<= /ar -qc $outAr *.o && rm *.o && popd/
    ['/bin/bash', '-c', cmd.toString()].execute().waitFor()
}
def sdkCopy(buildInfo, outFolder, all = true, staticToo = false,
            useFullBuildKey = false) {
    def arch = buildInfo.arch
    def buildKey = buildInfo.buildKey
    def cmakeFolder = getTempPath() + '/' + buildKey + '/.cmake'
    def buildFolder = getPackagePath() + '/' + outFolder
    def libBuildFolder = buildFolder + '/libs/' +
        (useFullBuildKey ? buildKey : arch ) + '/lib'

    copy {
        from file(cmakeFolder)
        include all ? "*/lib*.so" : "swappy*/lib*.so"
        into file(libBuildFolder)
        includeEmptyDirs = false
    }

    if (staticToo) {
        def staticsFolder = getOutPath() + '/' + buildKey
        def staticLibsBuildFolder = buildFolder + '/libs/' + buildKey
        def staticLibs = ['libswappy_static.a',
                          'libswappyVk_static.a']
        if (all)
            staticLibs += 'libtuningfork_static.a'
        repackArchives(staticsFolder, staticLibs, 'libgamesdk.a')
        copy {
            from file(staticsFolder)
            include "libgamesdk.a"
            into file(staticLibsBuildFolder)
        }
    }
}
def copyExtras(outFolder, all = true) {
    def buildFolder = getPackagePath() + '/' + outFolder
    def headerFolder = './include'
    def aarFolder = getOutPath() + '/outputs/aar'
    def includeBuildFolder = buildFolder + '/include'
    def aarBuildFolder = buildFolder + '/aar'

    copy {
        from file(headerFolder)
        include all ? "*/*.h" : "swappy*/*.h"
        into file(includeBuildFolder)
        includeEmptyDirs = false
    }
    copy {
        from file(aarFolder)
        into file(aarBuildFolder)
        includeEmptyDirs = false
    }
}
// The latest Unity is using NDK 16b and SDK 26 with gnu stl
def defaultAbis() { return ["armeabi-v7a", "arm64-v8a", "x86", "x86_64"] }
def unityNativeBuild() {
    return defaultAbis().collect { buildNativeModules(it, "26", "r16", "gnustl_shared", false) }
}
def sdkNativeBuild() {
    return defaultAbis().collectMany {
        [ buildNativeModules(it, "26", "r16", "gnustl_shared", false) ] +
        [ buildNativeModules(it, "28", "r17", "gnustl_shared", false) ] +
        [ buildNativeModules(it, "28", "r17", "c++_static", false) ] }
}
def localNativeBuild() {
    def kLocalMinSdk = "26"
    def stl = "c++_static"
    def toolchain = new LocalToolchain(project, kLocalMinSdk)
    return defaultAbis().collect {
        buildNativeModules(it, toolchain , stl, true)
    }
}
// Just build swappy
task swappyUnityBuild() {
    dependsOn ':extras:assembleRelease', 'check_protoc_version', 'make_proto'
    ext.packageName = 'swappyUnity'
    doLast {
        unityNativeBuild().each { sdkCopy(it, packageName, false) }
        copyExtras(packageName, false)
    }
}
// Full build including tuning fork for unity
task unityBuild() {
    dependsOn ':extras:assembleRelease', 'check_protoc_version', 'make_proto'
    ext.packageName = 'unity'
    doLast {
        unityNativeBuild().each { sdkCopy(it, packageName, true) }
        copyExtras(packageName, true)
    }
}

// Build everything
task sdkBuild() {
    dependsOn ':extras:assembleRelease', 'check_protoc_version', 'make_proto'
    ext.packageName = 'gamesdk'
    doLast {
        sdkNativeBuild().each { sdkCopy(it, packageName, true, true, true) }
        copyExtras(packageName, true)
    }
}

// Build using local SDK
task localBuild() {
    dependsOn ':extras:assembleRelease', 'check_protoc_version', 'make_proto'
    ext.packageName = 'local'
    doLast {
        localNativeBuild().each { sdkCopy(it, packageName, true, true, false) }
        copyExtras(packageName, true)
    }
}
// Zipping things up
def addZipTask(name, buildTask, zipName, rootName = "gamesdk") {
    def packPath = buildTask.packageName
    tasks.register(name, Zip) {
        dependsOn buildTask
        def buildFolder = Paths.get(getPackagePath(), packPath).toString()
        baseName = Paths.get(buildFolder, zipName).toString()

        from fileTree(buildFolder)
        exclude "*.zip"

        into rootName

        doLast {
            def out = services.get(StyledTextOutputFactory).create("ouput")
            out.style(Style.Identifier).text('\n'+packPath+' zip is in ')
            .style(Style.ProgressStatus)
                .println(baseName + '.zip' );
        }
    }

}
addZipTask("swappyUnityZip", swappyUnityBuild, "builds")
addZipTask("unityZip", unityBuild, "builds")
addZipTask("archiveZip", localBuild, "gamesdk")
addZipTask("gamesdkZip", sdkBuild, "gamesdk")
