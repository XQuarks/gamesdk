
import org.gradle.internal.logging.text.StyledTextOutput;
import org.gradle.internal.logging.text.StyledTextOutputFactory;
import static org.gradle.internal.logging.text.StyledTextOutput.Style;

defaultTasks 'clean', 'archiveZip'

def getAndroidNDKPath() {
  return System.getenv("ANDROID_NDK")
}

def getAndroidSDKPath() {
  return System.getenv("ANDROID_HOME")
}

ext.tempFolder = '.temp'
ext.buildFolder = 'build'
ext.androidNDK = getAndroidNDKPath()
ext.androidNDKVersion = "26"
ext.androidSDK = getAndroidSDKPath()

if (ext.androidSDK == null) {
  throw new GradleException('Must set ANDROID_HOME')
}

if (ext.androidNDK == null) {
  ext.androidNDK = ext.androidSDK + '/ndk-bundle'
  if (!file(ext.androidNDK).exists())
    throw new GradleException('No NDK found in SDK: must set ANDROID_NDK')
}

def findCMake() {
  def cmake = System.getenv("CMAKE");
  if (cmake != null) {
    return cmake;
  }

  def cmakes = fileTree(project.property('androidSDK')).matching { include 'cmake/*/bin/cmake' }
  if (cmakes.size() == 0) {
    throw new GradleException('No cmake found in ' + project.property('androidSDK') + 'cmake')
  }
  return cmakes.last();
}

ext.cmake = findCMake()

println "Build folder: $buildFolder"
println "Android SDK folder: $androidSDK"
println "Android NDK folder: $androidNDK"
println "Using cmake from: $cmake"

buildscript {
  repositories {
    google()
    jcenter()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:3.2.1'
  }
}

allprojects {
  repositories {
    google()
    jcenter()
  }
}

def cmake(projectFolder, cmakeFolder, arch, ndkVersion) {
  exec {
    workingDir cmakeFolder

    commandLine "$cmake",
     "$projectFolder",
     "-DCMAKE_BUILD_TYPE=Release ",
     "-DANDROID_PLATFORM=android-" + ndkVersion,
     "-DANDROID_NDK=" + project.property('androidNDK') + " ",
     "-DANDROID_STL=c++_static ",
     "-DANDROID_ABI=" + arch,
     "-DCMAKE_CXX_FLAGS= ",
     "-DCMAKE_TOOLCHAIN_FILE=" + project.property('androidNDK') + "/build/cmake/android.toolchain.cmake",
     "-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=./"
  }
}

def buildSwappy(arch, ndkVersion) {
  def cmakeFolder = project.property('tempFolder') + '/' + arch + '/.cmake'
  def buildFolder = project.property('buildFolder') + '/libs/' + arch

  mkdir cmakeFolder
  mkdir buildFolder

  exec {
    commandLine "$cmake", '--version'
  }

  cmake("$projectDir/src/swappy/", cmakeFolder, arch, ndkVersion)

  exec {
    workingDir cmakeFolder

    commandLine "make"
  }

  copy {
    from file(cmakeFolder + "/libswappy_static.a")
    into file(buildFolder)
  }
  copy {
    from file(cmakeFolder + "/libswappy.so")
    into file(buildFolder)
  }
}

task clean(type: Delete) {
  delete project.property('tempFolder')
  delete project.property('buildFolder')
}

task buildSwappyJavaLibs() {
  def buildFolder = project.property('buildFolder') + '/aar'
  def outputFolder = 'src/swappy/build/outputs/aar'

  dependsOn ':swappy:assembleRelease'
  doLast {
    copy {
      from file(outputFolder + "/swappy-release.aar")
      into file(buildFolder + "/swappy-release.aar")
    }
  }
}

task build(dependsOn: 'buildSwappyJavaLibs') {
  def includeFolder = project.property('buildFolder') + '/include'
  def buildFolder = project.property('buildFolder') + '/libs'
  doFirst {
    delete includeFolder
    mkdir includeFolder
  }

  def ndkVersion = project.property('androidNDKVersion')
  buildSwappy("armeabi-v7a", ndkVersion)
  buildSwappy("arm64-v8a", ndkVersion)

  doLast {
    copy {
      from "$projectDir/include/swappy"
      into includeFolder+"/swappy"
    }
  }
}

task archiveZip(type: Zip, dependsOn: 'build') {
  baseName = project.property('buildFolder') + '/gamesdk'

  from fileTree(project.property('buildFolder'))
  exclude "*.zip"
  exclude "*/x86/*"
  exclude "*/x86_64/*"
  into 'gamesdk'

  doLast {
    def out = services.get(StyledTextOutputFactory).create("ouput")

    out.style(Style.Identifier).text('\nGameSDK zip is in ')
      .style(Style.ProgressStatus)
      .println(project.property('buildFolder') + '/gamesdk.zip' );
  }
}

ext.tfTempFolder = '.temp_tf'
ext.tfBuildFolder = 'build_tf'
def buildTuningFork(arch, ndkVersion) {
  def tfcmakeFolder = project.property('tfTempFolder') + '/' + arch + '/.cmake'
  def tfbuildFolder = project.property('tfBuildFolder') + '/libs/' + arch

  mkdir tfcmakeFolder
  mkdir tfbuildFolder

  // Tuning fork

  cmake("$projectDir/src/tuningfork/", tfcmakeFolder, arch, ndkVersion)
  exec {
    workingDir tfcmakeFolder

    commandLine "make"
  }

  copy {
    from file(tfcmakeFolder + "/libtuningfork-static.a")
    into file(tfbuildFolder)
  }
  copy {
    from file(tfcmakeFolder + "/libtuningfork.so")
    into file(tfbuildFolder)
  }
}

task cleanTuningFork(type: Delete) {
  delete project.property('tfTempFolder')
  delete project.property('tfBuildFolder')
}

task buildForUnity(dependsOn: 'buildSwappyJavaLibs') {
  def includeFolder = project.property('tfBuildFolder') + '/include'
  doFirst {
    delete includeFolder
    mkdir includeFolder
  }

  def ndkVersion = project.property('androidNDKVersion')
  buildSwappy("armeabi-v7a", ndkVersion)
  buildSwappy("arm64-v8a", ndkVersion)
  buildSwappy("x86", ndkVersion)
  buildSwappy("x86_64", ndkVersion)
  buildTuningFork("armeabi-v7a", ndkVersion)
  buildTuningFork("arm64-v8a", ndkVersion)
  buildTuningFork("x86", ndkVersion)
  buildTuningFork("x86_64", ndkVersion)

  doLast {
    copy {
      from "$projectDir/include/tuningfork"
      into includeFolder+"/tuningfork"
    }
  }
}

task unityZip(type: Zip, dependsOn: 'buildForUnity') {
  baseName = project.property('buildFolder') + '/builds'

  from fileTree(project.property('buildFolder'))
  exclude "*.zip"
  from fileTree(project.property('tfBuildFolder'))
  exclude "*.zip"

  doLast {
    def out = services.get(StyledTextOutputFactory).create("ouput")

    out.style(Style.Identifier).text('\nUnity zip is in ')
      .style(Style.ProgressStatus)
      .println(project.property('buildFolder') + '/builds.zip' );
  }
}
